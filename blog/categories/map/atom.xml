<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Map | Coding Forest]]></title>
  <link href="http://jivimberg.github.io/blog/categories/map/atom.xml" rel="self"/>
  <link href="http://jivimberg.github.io/"/>
  <updated>2019-08-12T07:55:52-07:00</updated>
  <id>http://jivimberg.github.io/</id>
  <author>
    <name><![CDATA[Juan Ignacio Vimberg]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Map.merge]]></title>
    <link href="http://jivimberg.github.io/blog/2018/07/20/map-dot-merge/"/>
    <updated>2018-07-20T07:32:49-07:00</updated>
    <id>http://jivimberg.github.io/blog/2018/07/20/map-dot-merge</id>
    <content type="html"><![CDATA[<p>Sometimes is the small thingsâ€¦ Like finding a new method that does exactly what you were needing.</p>

<!--more-->


<p>Letâ€™s say Iâ€™m trying to build a book index. In case you havenâ€™t touch an actual, physical, <em>dead-tree</em> book in a while hereâ€™s what an index looks like<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>:</p>

<p>{% img center /images/posts/2018-07-20/index.gif &lsquo;Discoverability&rsquo; %}</p>

<p>One way of doing this would be to <strong>build a map of: <em>terms</em> to <em>a list of comma separated pages</em></strong>. This is, by no means, the best way of modeling an index, but itâ€™ll serve our purpose of illustrating the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#merge-K-V-java.util.function.BiFunction-"><code>Map.merge</code></a> method.</p>

<p>Up until yesterday Iâ€™d have written such code like this:</p>

<p>{% codeblock lang:java %}
public class Index {
    private final Map&lt;String, String> termToPagesMap = new HashMap&lt;>();</p>

<pre><code>public void addWord(String term, int page) {
    final String newPage = String.valueOf(page);
    final String pages = termToPagesMap.get(term);
    if (pages == null) {
        termToPagesMap.put(term, newPage);
    } else {
        termToPagesMap.put(term, pages.concat(", " + newPage));
    }
}
</code></pre>

<p>}</p>

<p>{% endcodeblock %}</p>

<p><strong>But today I know better!</strong> With <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#merge-K-V-java.util.function.BiFunction-"><code>Map.merge</code></a> I can achieve the same result in just 1 line:</p>

<p>{% codeblock lang:java %}
public class Index {
    private final Map&lt;String, String> termToPagesMap = new HashMap&lt;>();</p>

<pre><code>public void addWord(String term, int page) {
        termToPagesMap.merge(term, String.valueOf(page), (pages, newPage) -&gt; pages.concat(", " + newPage));
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>Basically we provide:</p>

<ul>
<li>The entry <strong>key</strong></li>
<li>A <strong>value</strong> to be used if there was no associated value to the key (or it was <code>null</code>)</li>
<li>A <strong>Â remapping function</strong> that takes the <strong>old value</strong>, the <strong>new value</strong> and calculates the new value for the map</li>
</ul>


<h2>Bonus track: Removal</h2>

<p>Thereâ€™s one more trick you can do with <code>Map.merge</code>. Citing the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#merge-K-V-java.util.function.BiFunction-">documentation</a>:</p>

<blockquote><p>If the function returnsÂ <code>null</code>Â the mapping is removed</p></blockquote>

<p>Something to keep in mind in case it comes in handy in the future. Or if you find yourself debugging an issue of <em>â€vanishing entries on a Mapâ€</em>, then maybe you should check your <strong>Â remapping function</strong> ğŸ˜‰</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Iâ€™m aware that ebooks have indexes too, but who the fuck uses them when you can do a full blown text search<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
