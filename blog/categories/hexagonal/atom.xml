<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Hexagonal | Coding Forest]]></title>
  <link href="http://jivimberg.io/blog/categories/hexagonal/atom.xml" rel="self"/>
  <link href="http://jivimberg.io/"/>
  <updated>2023-09-13T06:30:37+00:00</updated>
  <id>http://jivimberg.io/</id>
  <author>
    <name><![CDATA[Juan Ignacio Vimberg]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Hexagonal Architecture on Spring Boot]]></title>
    <link href="http://jivimberg.io/blog/2020/02/01/hexagonal-architecture-on-spring-boot/"/>
    <updated>2020-02-01T20:51:59-08:00</updated>
    <id>http://jivimberg.io/blog/2020/02/01/hexagonal-architecture-on-spring-boot</id>
    <content type="html"><![CDATA[<p>In this article, I&rsquo;ll show how to implement a Spring Boot application using Hexagonal Architecture.</p>

<!--more-->


<p>We&rsquo;ll build a Bank Account simulation with <em>deposit</em> and <em>withdraw</em> operations exposed through REST endpoints.</p>

<h2>Hexagonal Architecture</h2>

<p>Hexagonal architecture is an architectural style that <strong>focuses on keeping the business logic decoupled from external concerns</strong>.</p>

<p>The business core interacts with other components through ports and adapters. This way, we can change the underlying technologies without having to modify the application core.</p>

<p>{% img center /images/posts/2020-02-01/HexagonalArchitecture-generic.png 700 ‘Generic Hexagonal Architecture diagram’ %}</p>

<h2>Application Core</h2>

<h3>Domain Model</h3>

<p>Let&rsquo;s start with the domain model. Its main responsibility is to model the business rules. It also verifies that the objects are always in a valid state:</p>

<p>{% codeblock lang:java BankAccount.java %}
public class BankAccount {</p>

<pre><code>    private Long id;
    private BigDecimal balance;

    // Constructor

    public boolean withdraw(BigDecimal amount) {
        if(balance.compareTo(amount) &lt; 0) {
            return false;
        }

        balance = balance.subtract(amount);
        return true;
    }

    public void deposit(BigDecimal amount) {
        balance = balance.add(amount);
    }
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>The domain model should have no dependency on any specific technology. That&rsquo;s the reason why you&rsquo;ll find no Spring annotations here.</p>

<h3>Ports</h3>

<p>Now it&rsquo;s time to have our business logic interact with the outside world. To achieve this, we&rsquo;ll introduce some ports.</p>

<p>First, let&rsquo;s define 2 incoming ports. <strong>These are used by external components to call our application</strong>. In this case, we&rsquo;ll have one per use case. One for <em>Deposit</em>:</p>

<p>{% codeblock lang:java DepositUseCase.java %}
public interface DepositUseCase {
        void deposit(Long id, BigDecimal amount);
}
{% endcodeblock %}</p>

<p>And one for <em>Withdraw</em>:</p>

<p>{% codeblock lang:java WithdrawUseCase.java %}
public interface WithdrawUseCase {
        boolean withdraw(Long id, BigDecimal amount);
}
{% endcodeblock %}</p>

<p>Similarly, we&rsquo;ll also have 2 outgoing ports. <strong>These are for our application to interact with the database</strong>. Once again, we&rsquo;ll have one per use case. One for <em>Loading</em> the Account:</p>

<p>{% codeblock lang:java LoadAccountPort.java %}
public interface LoadAccountPort {
        Optional<BankAccount> load(Long id);
}
{% endcodeblock %}</p>

<p>And one for <em>Saving</em> it:</p>

<p>{% codeblock lang:java SaveAccountPort.java %}
public interface SaveAccountPort {
        void save(BankAccount bankAccount);
}
{% endcodeblock %}</p>

<h3>Service</h3>

<p>Next, we&rsquo;ll create a service to tie all the pieces together and drive the execution:</p>

<p>{% codeblock lang:java BankAccountService.java %}
public class BankAccountService implements DepositUseCase, WithdrawUseCase {</p>

<pre><code>    private LoadAccountPort loadAccountPort;
    private SaveAccountPort saveAccountPort;

    // Constructor

    @Override
    public void deposit(Long id, BigDecimal amount) {
        BankAccount account = loadAccountPort.load(id)
                .orElseThrow(NoSuchElementException::new);

        account.deposit(amount);

        saveAccountPort.save(account);
    }

    @Override
    public boolean withdraw(Long id, BigDecimal amount) {
        BankAccount account = loadAccountPort.load(id)
                .orElseThrow(NoSuchElementException::new);

        boolean hasWithdrawn = account.withdraw(amount);

        if(hasWithdrawn) {
            saveAccountPort.save(account);
        }
        return hasWithdrawn;
    }
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>Note how the service implements the incoming ports. On each method, it uses the <em>Load</em> port to fetch the account from the database. Then, it performs the changes on the domain model. And finally, it saves those changes through the <em>Save</em> port.</p>

<h2>Adapters</h2>

<h3>Web</h3>

<p>To complete our application, we need to provide implementations for the defined ports. We call these adapters.</p>

<p>For the incoming interactions, we&rsquo;ll create a REST controller:</p>

<p>{% codeblock lang:java BankAccountController.java %}
@RestController
@RequestMapping(&ldquo;/account&rdquo;)
public class BankAccountController {</p>

<pre><code>    private final DepositUseCase depositUseCase;
    private final WithdrawUseCase withdrawUseCase;

    // Constructor

    @PostMapping(value = "/{id}/deposit/{amount}")
    void deposit(@PathVariable final Long id, @PathVariable final BigDecimal amount) {
        depositUseCase.deposit(id, amount);
    }

    @PostMapping(value = "/{id}/withdraw/{amount}")
    void withdraw(@PathVariable final Long id, @PathVariable final BigDecimal amount) {
        withdrawUseCase.withdraw(id, amount);
    }
}
</code></pre>

<p>{% endcodeblock %}</p>

<p>The controller uses the defined ports to make calls to the application core.</p>

<h3>Persistence</h3>

<p>For the persistence layer, we&rsquo;ll use Mongo DB through Spring Data:</p>

<p>{% codeblock lang:java SpringDataBankAccountRepository.java %}
public interface SpringDataBankAccountRepository extends MongoRepository&lt;BankAccount, Long> { }
{% endcodeblock %}</p>

<p>Also, we&rsquo;ll create a <em>BankAccountRepository</em> class that connects the outgoing ports with the <em>SpringDataBankAccountRepository</em>:</p>

<p>{% codeblock lang:java BankAccountRepository.java %}
@Component
public class BankAccountRepository implements LoadAccountPort, SaveAccountPort {</p>

<pre><code>    private SpringDataBankAccountRepository repository;

    // Constructor

    @Override
    public Optional&lt;BankAccount&gt; load(Long id) {
        return repository.findById(id);
    }

    @Override
    public void save(BankAccount bankAccount) {
        repository.save(bankAccount);
    }
</code></pre>

<p>}</p>

<p>{% endcodeblock %}</p>

<h3>Infrastructure</h3>

<p>Finally, we need to tell Spring to expose the <em>BankAccountService</em> as a bean, so it can be injected in the controller:</p>

<p>{% codeblock lang:java BeanConfiguration.java %}
@Configuration
@ComponentScan(basePackageClasses = HexagonalApplication.class)
public class BeanConfiguration {</p>

<pre><code>    @Bean
    BankAccountService bankAccountService(BankAccountRepository repository) {
        return new BankAccountService(repository, repository);
    }
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>Defining the beans in the Adapters layer helps us maintain the infrastructure code decoupled from the business logic.</p>

<h2>Conclusion</h2>

<p>In this article, we&rsquo;ve seen how to implement an application using Hexagonal Architecture and Spring Boot. This is what the system ends up looking like:</p>

<p>{% img center /images/posts/2020-02-01/HexagonalArchitecture-impl.png 700 ‘Generic Hexagonal Architecture Spring Boot example’ %}</p>

<p>The code for this example is <a href="https://github.com/jivimberg/hexagonal-architecture">available on Github</a>.</p>

<hr />

<p>This article is based on the <em>highly recommendable</em> <a href="https://leanpub.com/get-your-hands-dirty-on-clean-architecture">&ldquo;Get Your Hands Dirty on Clean Architecture</a> by <a href="https://twitter.com/TomHombergs">Tom Hombergs</a>, and <a href="https://www.baeldung.com/hexagonal-architecture-ddd-spring">this Baeldung article</a> by <a href="https://www.baeldung.com/author/lukasz-rys/">Łukasz Ryś</a>.</p>

<p> {% img right-fill /images/signatures/signature9.png 200 ‘My signature’ %}</p>
]]></content>
  </entry>
  
</feed>
