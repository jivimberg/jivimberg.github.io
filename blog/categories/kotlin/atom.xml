<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Kotlin | Coding Forest]]></title>
  <link href="http://jivimberg.github.io/blog/categories/kotlin/atom.xml" rel="self"/>
  <link href="http://jivimberg.github.io/"/>
  <updated>2023-03-06T13:22:46-08:00</updated>
  <id>http://jivimberg.github.io/</id>
  <author>
    <name><![CDATA[Juan Ignacio Vimberg]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Adding Context to Extension Functions]]></title>
    <link href="http://jivimberg.github.io/blog/2021/08/21/adding-context-to-extension-functions/"/>
    <updated>2021-08-21T20:24:14-07:00</updated>
    <id>http://jivimberg.github.io/blog/2021/08/21/adding-context-to-extension-functions</id>
    <content type="html"><![CDATA[<p>Extension functions are great! But if you define them all over the place, it can get confusing pretty quickly. So here‚Äôs a cool idiom to limit extension function usage to a specific context.</p>

<!--more-->


<p>Last week I needed to write some code to generate <a href="https://github.com/Netflix/atlas/wiki/Stack-Language">Atlas Stack Language (ASL)</a> queries. ASL is loosely based on <a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation">Reverse Polish Notation</a>, so you first specify the parameters and then the operation. The query I was trying to generate looked something like this:</p>

<p> <code>appName,myapp,:eq,userName,juan,:eq,:and</code></p>

<p>I already had methods for the <code>appName</code> and <code>userName</code> parts and was trying to write the method for the <code>:and</code> operator. So I started by writing the tests:</p>

<div class="kotlin-code" data-target-platform="junit" theme="darcula">
import org.junit.Assert.assertEquals
import org.junit.Assert.assertNull
import org.junit.Test

internal class ASLQueryBuilderTestV1 {

    //sampleStart

    // Tests will fail because `and` hasn't been implemented yet

    @Test
    fun `and should return correct expr if neither param is null`() {
        val expr = and("one", "two")
        assertEquals("one,two,:and", expr)
    }

    @Test
    fun `and should return first param if second param is null`() {
        val expr = and("one", null)
        assertEquals("one", expr)
    }

    @Test
    fun `and should return second param if receiver is null`() {
        val expr = and(null, "two")
        assertEquals("two", expr)
    }

    @Test
    fun `and should return null if both params are null`() {
        val expr = and(null, null)
        assertNull(expr)
    }
    //sampleEnd
}
</div>


<p>Ok, that‚Äôs a lie üôà I didn‚Äôt really start with the tests, as <a href="https://en.wikipedia.org/wiki/Test-driven_development">TDD</a> suggests. But let‚Äôs pretend I did for this example because the test does a good job at explaining the behavior I was going for. Note that the <code>:and</code> operator is only applied if both expressions are not <em>null</em>.</p>

<p>So here&rsquo;s a straightforward implementation that makes all the tests go ‚úÖ:</p>

<div class="kotlin-code" data-target-platform="junit" theme="darcula">
import org.junit.Assert.assertEquals
import org.junit.Assert.assertNull
import org.junit.Test

internal class ASLQueryBuilderTestV1 {

    @Test
    fun `and should return correct expr if neither param is null`() {
        val expr = and("one", "two")
        assertEquals("one,two,:and", expr)
    }

    @Test
    fun `and should return first param if second param is null`() {
        val expr = and("one", null)
        assertEquals("one", expr)
    }

    @Test
    fun `and should return second param if receiver is null`() {
        val expr = and(null, "two")
        assertEquals("two", expr)
    }

    @Test
    fun `and should return null if both params are null`() {
        val expr = and(null, null)
        assertNull(expr)
    }
}

//sampleStart
fun and(expr1: String?, expr2: String?): String? {
    return when {
        expr1 != null && expr2 != null -> "$expr1,$expr2,:and"
        expr1 != null && expr2 == null -> expr1
        expr1 == null && expr2 != null -> expr2
        else -> null
    }
}
//sampleEnd
</div>


<p>My <code>and()</code> method was working, but it was not beautiful. Every time I read it, I had to do some mental gymnastics to understand what was going on üß†üèã</p>

<p>Here, judge for yourself:</p>

<div class="kotlin-code" theme="darcula" data-highlight-only>
val expr = and(appNameEquals("myapp"), userNameEquals("juan"))
//      ü§î <- me thinking 
// expr means      (appName == myapp) AND (userName == juan)"
// expr generated  "appName,myapp,:eq,userName,juan,:eq,:and"
</div>


<p>So I had an idea, what if I write it as an <a href="https://kotlinlang.org/docs/functions.html#infix-notation"><code>infix</code> function</a>? Infix functions can only take a single parameter, and I need to receive two expressions, so my only option was to make <code>and</code> an extension function. And that‚Äôs what I did:</p>

<div class="kotlin-code" data-target-platform="junit" theme="darcula">
import org.junit.Assert.assertEquals
import org.junit.Assert.assertNull
import org.junit.Test

internal class ASLQueryBuilderTestV1 {

    @Test
    fun `and should return correct expr if neither param is null`() {
        val expr = "one" and "two"
        assertEquals("one,two,:and", expr)
    }

    @Test
    fun `and should return first param if second param is null`() {
        val expr = "one" and null
        assertEquals("one", expr)
    }

    @Test
    fun `and should return second param if receiver is null`() {
        val expr = null and "two"
        assertEquals("two", expr)
    }

    @Test
    fun `and should return null if both params are null`() {
        val expr = null and null
        assertNull(expr)
    }
}

//sampleStart
infix fun String?.and(other: String?): String? {
    return when {
        this != null && other != null -> "$this,$other,:and"
        this != null && other == null -> this
        this == null && other != null -> other
        else -> null
    }
}
//sampleEnd
</div>


<p>Ahh! This reads almost like English. <em>Me like it very much!</em></p>

<p>Except for one thing&hellip;</p>

<p><code>String?</code> is a pretty basic type, and <code>and()</code> is a pretty common function name. Months from now, somebody will be writing some code and IntelliJ will suggest this:</p>

<p>{% img center /images/posts/2021-08-21/wrong-suggestion.png %}</p>

<p>üò± Watch out unsuspecting coder! That <code>and</code> function doesn&rsquo;t do what you think it does!</p>

<p>Leaving this extension function around might be dangerous. So, how can we restrict callers to use it only when writing ASL queries?</p>

<h2>Extension member functions to the rescue!</h2>

<p>The trick is to create a new class named <code>AslQueryBuilder</code> and make <code>and()</code> a member function of this class. By doing so, we make sure the extension function can only be called from an instance of <code>AslQueryBuilder</code>. Nobody will confuse <code>AslQueryBuilder.and()</code> with <code>String.plus()</code>.</p>

<div class="kotlin-code" theme="darcula" data-highlight-only>
class ASLQueryBuilder {
    infix fun String?.and(other: String?): String? {
        return when {
            this != null && other != null -> "$this,$other,:and"
            this != null && other == null -> this
            this == null && other != null -> other
            else -> null
        }
    }
}
</div>


<p>IntelliJ will no longer suggest <code>and()</code> to any random <code>String?</code> unless AslQueryBuilder is in scope. Problem solved! üí™</p>

<p>We can use Kotlin&rsquo;s <code>with()</code> function to put an instance of <code>AslQueryBuilder</code> in scope to call <code>and()</code>.</p>

<div class="kotlin-code" data-target-platform="junit" theme="darcula">
import org.junit.Assert.assertEquals
import org.junit.Assert.assertNull
import org.junit.Test

internal class ASLQueryBuilderTestV3 {
    //sampleStart
    private val aslQueryBuilder = ASLQueryBuilder()

    @Test
    fun `and should return correct expr if neither param is null`() {
        val expr = with(aslQueryBuilder) { "one" and "two" }
        expectThat(expr).isEqualTo("one,two,:and")
    }

    @Test
    fun `and should return first param if second param is null`() {
        val expr = with(aslQueryBuilder) { "one" and null }
        expectThat(expr).isEqualTo("one")
    }

    @Test
    fun `and should return second param if receiver is null`() {
        val expr = with(aslQueryBuilder) { null and "two" }
        expectThat(expr).isEqualTo("two")
    }

    @Test
    fun `and should return null if both params are null`() {
        val expr = with(aslQueryBuilder) { null and null }
        expectThat(expr).isNull()
    }
    //sampleEnd
}

infix fun String?.and(other: String?): String? {
    return when {
        this != null && other != null -> "$this,$other,:and"
        this != null && other == null -> this
        this == null && other != null -> other
        else -> null
    }
}
</div>


<h2>Putting it all together</h2>

<p>Now that we have an <code>ASLQueryBuilder</code> class, let&rsquo;s add the other two required methods in there too:</p>

<div class="kotlin-code" theme="darcula">
class ASLQueryBuilder {

    infix fun String?.and(other: String?): String? {
        return when {
            this != null && other != null -> "$this,$other,:and"
            this != null && other == null -> this
            this == null && other != null -> other
            else -> null
        }
    }

    fun appNameEquals(appName: String?): String? {
        return appName?.let { ":appName,$it,eq" }
    }

    fun userNameEquals(userName: String?): String? {
        return userName?.let { ":userName,$it,eq" }
    }
}

fun main() {
    val aslQueryBuilder = ASLQueryBuilder()
    val finalExpression = with(aslQueryBuilder) {
        appNameEquals("myApp") and userNameEquals("juan")
    }
    print(finalExpression) // :appName,myApp,eq,:userName,juan,eq,:and
}
</div>


<p>And that‚Äôs it! The query generation code reads nicely and is easy to understand, and <strong>developers can&rsquo;t call the functions without the explicit <code>ASLQueryBuilder</code> context instance, so nobody will use them accidentally</strong>. With this technique we can add any extensions we want to common types without worrying it might pollute the auto-complete and be misused.</p>

<hr />

<p>That‚Äôs all for today! If you liked this approach, make sure to check <a href="https://proandroiddev.com/an-introduction-context-oriented-programming-in-kotlin-2e79d316b0a2">An introduction to context-oriented programming in Kotlin</a> and <a href="https://github.com/Kotlin/KEEP/blob/context-receivers/proposals/context-receivers.md#contextual-functions-and-property-accessors">KEEP-259</a> for what might come in future versions of Kotlin.</p>

<p>{% img right-fill /images/signatures/signature13.png 200 ‚ÄòMy signature‚Äô %}</p>

<p><script src="https://unpkg.com/kotlin-playground@1" data-selector=".kotlin-code"\></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mockk All the Things]]></title>
    <link href="http://jivimberg.github.io/blog/2019/05/09/mockk-features-rundown/"/>
    <updated>2019-05-09T07:57:47-07:00</updated>
    <id>http://jivimberg.github.io/blog/2019/05/09/mockk-features-rundown</id>
    <content type="html"><![CDATA[<p>Over the last few years Mockk has been gaining ground as the go-to mocking library in KotlinWorld ‚Ñ¢. Just recently, it was listed as <em>‚Äúadopt‚Äù</em> in the <a href="https://www.thoughtworks.com/radar/languages-and-frameworks/mockk">ThoughtWorks technology Radar</a>. Want to know what all the fuss is about?</p>

<!--more-->


<p>{% img center /images/posts/2019-05-18/mockkAllTheThings.gif ‚ÄòChannels animation‚Äô %}</p>

<h2>Regular mocking</h2>

<p>Let‚Äôs start with the basics. You can <em>mock</em>, <em>spy</em> and <em>verify</em> using this <a href="https://mockk.io/#dsl-tables">cute little DSL</a></p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
import io.mockk.every
import io.mockk.mockk
import io.mockk.spyk
import io.mockk.verify
import org.junit.jupiter.api.Test

class ClockTest {

//sampleStart
    @Test
    fun `regular mock`() {
        val clock = mockk<Clock>()
        every { clock.currentTime() } returns "7:20"
    
        clock.currentTime()
    
        verify { clock.currentTime() }
    }
    
    @Test
    fun `regular spy`() {
        val clock = spyk<Clock>()
    
        clock.currentTime()
    
        verify { clock.currentTime() }
    }
    //sampleEnd
}
</xmp>


<h2>Mocks with behavior</h2>

<p>No need to settle for just one fixed return value. You can add complex behavior to your mocks like this:</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
class ClockTest {
    //sampleStart
    @Test
    fun `mock with complex behavior`() {
        val clock = mockk<Clock>()
        every { clock.currentTime() } answers { dateFormat.format(Calendar.getInstance()) }
    
        // ...
    }
    
    companion object {
        val dateFormat = SimpleDateFormat("HH:mm")
    }
    //sampleEnd
}
</xmp>


<p>There are a bunch of utility functions and properties you can use inside the <code>answers</code> lambda to do things like calculate the response based on the function arguments. Full list <a href="http://mockk.io/#answer-scope">here</a>.</p>

<h2>Mock chained calls</h2>

<p>You can easily mock a chain of calls</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
class ClockTest {
    //sampleStart
    @Test
    fun `mocking chained calls`() {
        val oven = mockk<Oven>()
        every { oven.clock.currentTime() } returns "7:20"
    
        //...
    }
    //sampleEnd
}
</xmp>


<h2>Mock hierarchies</h2>

<p>You can achieve the same result using hierarchical mocking</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
class ClockTest {
    //sampleStart
    @Test
    fun `hierarchical mocking`() {
        val oven = mockk<Oven>()
        every { oven.clock } returns mockk {
            every { currentTime() } returns "7:20"
        }
    
        //...
    }
    //sampleEnd
}
</xmp>


<p>This is especially useful when mocking complex structures and to return collections of mocking objects, like in <a href="https://mockk.io/#hierarchical-mocking">this example</a>.</p>

<h2>Mock objects</h2>

<p>You can mock Objects as easily as you mock regular classes</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
class ClockTest {
    //sampleStart
    @Test
    fun `object mocking`() {
        mockkObject(UrlHelper)
        every { UrlHelper.getBaseUrl() } returns URL("http://mockUrl.com")
    
        //...
    }
    //sampleEnd
}
</xmp>


<h2>Mock Unit</h2>

<p>You can mock functions that return <code>Unit</code> using <code>just Runs</code></p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
class ClockTest {
    //sampleStart
    @Test
    fun `mocking functions that return Unit`() {
        val clock = mockk<Clock>()
        every { clock.changeBatteries() } just Runs
    
        //...
    }
    //sampleEnd
}
</xmp>


<h2>Mock Nothing</h2>

<p>Or functions that return Nothing. In which case you have to throw an exception as behavior (because a function that returns <code>Nothing</code> <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-nothing.html">never returns</a> and can only end by throwing an exception, remember?)</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
class ClockTest {
    //sampleStart
    @Test
    fun `mocking functions that return Nothing`() {
        val clock = mockk<Clock>()
        every { clock.runForever() } throws Exception("called runForever")
    
        //...
    }
    //sampleEnd
}
</xmp>


<h2>Mock extensions functions</h2>

<p>You can mock extensions functions as well:</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
class ClockTest {
    //sampleStart
    @Test
    fun `mocking functions extension functions`() {
        with(mockk<Clock>()) {
            every { Duration.ofMinutes(5).startTimer() } returns true
    
            //...
        }
    }
    //sampleEnd
}
</xmp>


<p>This works If the extension functions is defined on a class or an object. If it‚Äôs defined as a top level function instead, you can still mock it by following the advise in the next point üëá</p>

<h2>Mocking top level functions</h2>

<p>Got a top level function to mock? We‚Äôve got you covered.</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
   class ClockTest {
   //sampleStart
    @Test
    fun `mocking top level functions`() {
        mockkStatic("mockk.ModelsKt")
        every { resolve(any()) } returns URL("http://mockk.com/users/1")
    
        //...
    }
    //sampleEnd
}
</xmp>


<p>Ok, you might need to check your classes to know exactly what to use as argument for <code>mockkStatic</code>, but it‚Äôs no big deal.</p>

<h2>Mock private functions</h2>

<p>Yep, you can mock private functions by name.</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
class ClockTest {
    //sampleStart
    @Test
    fun `mocking private functions`() {
        val oven = mockk<Oven>()
        every { oven["lockDoor"]() } returns true
        
        //...
    }
    //sampleEnd
}
</xmp>


<p>You can even verify calls to private function by using <code>recordPrivateCalls = true</code></p>

<h2>Mock varargs</h2>

<p>There‚Äôs also support for mocking functions that use varargs:</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
class VarargsTest {
    //sampleStart
    interface Calculator {
        fun sumEverything(vararg num: Int): Int
    }

    @Test
    fun `mocking varargs`() {
        val calculator = mockk<Calculator>()
        every { calculator.sumEverything(1, 2, 4) } returns 7

        //...

        every { calculator.sumEverything(1, *anyIntVararg(), 4) } returns 12

        //...

        every { calculator.sumEverything(1, *varargAllInt { it < 5 }) } returns 10

        //...
    }
    //sampleEnd
}
</xmp>


<p>And it‚Äôs not only the basics either. As you can see in the example you can do all kind of complex matchings.</p>

<h2>Mock constructor</h2>

<p>You can mock constructors. Useful for those times when you don‚Äôt actually control the object creation, but want to still be able to mock it.</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
class ClockTest {
    //sampleStart
    @Test
    fun `mocking constructor`() {
        mockkConstructor(Clock::class)

        every { anyConstructed<Clock>().currentTime() } returns "7:40"

        assertEquals("7:40", Clock().currentTime())
    }
    //sampleEnd
}
</xmp>


<h2>Mock coroutines</h2>

<p>If you‚Äôre working with coroutines and want to mock a suspending function you simply use <code>coEvery</code>. In this example <code>startTimer</code> is a suspending function:</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
class ClockTest {
    //sampleStart
    @Test
    fun `mocking suspending functions`() {
        val clock = mockk<Clock>()
        coEvery { clock.startTimer() } returns RUNNING

        // ...
    }
    //sampleEnd
}
</xmp>


<p>Along with <code>coEvery</code> there‚Äôs a whole family of <code>co...</code> functions (<code>coAnswers</code>, <code>coVerify</code>, <code>coAssert</code>, etc.) for working with coroutines.</p>

<hr />

<p>This is by no means a comprehensive guide. My intention was just to showcase same of the things that Mockk can do for you. For an in-depth introduction I recommend checking the <a href="https://blog.kotlin-academy.com/search?q=mockk"><em>‚ÄúMocking is not rocket science‚Äù</em> series in Kotlin Academy</a>.</p>

<p> {% img right-fill /images/signatures/signature10.png 200 ‚ÄòMy signature‚Äô %}</p>

<script src="https://unpkg.com/kotlin-playground@1" data-selector=".kotlin-code"></script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Different Kinds of Channels in Kotlin]]></title>
    <link href="http://jivimberg.github.io/blog/2019/04/18/different-kinds-of-channels-in-kotlin/"/>
    <updated>2019-04-18T07:59:14-07:00</updated>
    <id>http://jivimberg.github.io/blog/2019/04/18/different-kinds-of-channels-in-kotlin</id>
    <content type="html"><![CDATA[<p>Overview of the different kinds of Kotlin channels and their behaviors.</p>

<!--more-->


<p>{% img center /images/posts/2019-04-18/Channels.gif  600 ‚ÄòChannels animation‚Äô %}</p>

<h2>Rendezvous</h2>

<p>{% img right /images/posts/2019-04-18/baton.jpg 250 ‚ÄòPassing the baton‚Äô %}</p>

<p>In Rendezvous channels capacity is 0. Which means the channel has no buffer at all. Elements are transferred only when sender and receiver meet. Which is literally what <em>Rendezvous</em> means. I like to picture it as a <a href="https://en.wikipedia.org/wiki/Relay_race">relay race</a> where the runners need to meet at one point to pass the baton.</p>

<p>In technical terms this means that¬†<code>send</code>¬†<em>suspends</em> until another coroutine invokes¬†<code>receive</code>,¬†and¬†<code>receive</code>¬†<em>suspends</em> until another coroutine invokes¬†<code>send</code>.</p>

<h2>Buffered</h2>

<p>Buffered channels have a positive capacity but are not <code>Unlimited</code>. Calling <code>send</code> <em>suspends</em> only if the buffer is full. And calling <code>receive</code> <em>suspends</em> only if buffer is empty (i.e. there are no more messages in the channel).</p>

<h2>Unlimited</h2>

<p>You guessed it. Unlimited buffer. Sender will never <em>suspend</em> on <code>send</code>.</p>

<p>But there‚Äôs no such thing as <em>Unlimited</em>, right? The implementation uses a linked-list buffer so your only constraint is memory.</p>

<h2>Conflated</h2>

<p>This is the oddball. The sender never <em>suspends</em>, but the channel offers at most one element at any given time. When a new element comes, the previous element in the channel (if any) is discarded. The receiver only gets the most recent element sent. Previous elements are lost.</p>

<p>{% img right-fill /images/signatures/signature7.png 200 ‚ÄòMy signature‚Äô %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SQS Consumer Using Kotlin Coroutines]]></title>
    <link href="http://jivimberg.github.io/blog/2019/02/23/sqs-consumer-using-kotlin-coroutines/"/>
    <updated>2019-02-23T16:52:48-03:00</updated>
    <id>http://jivimberg.github.io/blog/2019/02/23/sqs-consumer-using-kotlin-coroutines</id>
    <content type="html"><![CDATA[<p>Today we‚Äôll see how to write a SQS consumer that processes messages in a parallel, non-blocking way, using Kotlin coroutines.</p>

<!--more-->


<h2>The pool of workers pattern</h2>

<p>After some experimentation I‚Äôve opted for using a <em>pool of workers</em> for writing the consumer. For an introduction on the pattern and how to implement it in Kotlin I strongly suggested watching Roman‚Äôs talk from 2018 Kotlin Conf.</p>

<div style="text-align: center;">
    <iframe width="560" height="315" src="https://www.youtube.com/embed/a3agLJQ6vt8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>


<p>For our particular solution we‚Äôll need:</p>

<ol>
<li>One coroutine that periodically retrieves the messages (<strong>MsgReceiver</strong>).</li>
<li>Multiple <strong>workers</strong> that process the receiving messages in parallel without blocking.</li>
<li>A <strong>channel</strong> to communicate between the <em>MsgReceiver</em> coroutine and the <em>Workers</em>.</li>
</ol>


<p>{% img center /images/posts/2019-03-10/consumerDiagram.png 800 ‚ÄòSQS consumer diagram‚Äô %}</p>

<h3><em>fun start()</em></h3>

<p>Let‚Äôs start by creating the elements we mentioned in the previous section. We‚Äôll do this in the <code>start()</code> method.</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
fun start() = launch {
        val messageChannel = Channel<Message>()
        repeat(N_WORKERS) { launchWorker(messageChannel) }
        launchMsgReceiver(messageChannel)
    }
</xmp>


<p>This function launches a coroutine that creates: the channel, <em>N</em> <em>workers</em> and the <em>MsgReceiver</em>.</p>

<p>Don‚Äôt worry too much about how we‚Äôre able to call <code>launch</code> here. I‚Äôll go back to this later.</p>

<h3>Message receiver</h3>

<p>Now it‚Äôs time to write the code for the message receiver:</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
private fun CoroutineScope.launchMsgReceiver(channel: SendChannel<Message>) = launch {
        repeatUntilCancelled {
            val receiveRequest = ReceiveMessageRequest.builder()
                    .queueUrl(SQS_URL)
                    .waitTimeSeconds(20)
                    .maxNumberOfMessages(10)
                    .build()
    
            val messages = sqs.receiveMessage(receiveRequest).await().messages()
            println("${Thread.currentThread().name} Retrieved ${messages.size} messages")
    
            messages.forEach {
                channel.send(it)
            }
        }
    }
</xmp>


<p>This function takes a <code>SendChannel</code> that it‚Äôll use to communicate with the <em>worker</em> coroutines.</p>

<p>It is written as a <code>CoroutineScope</code> to denote that it creates a new coroutine and does not wait for it to complete.</p>

<p>Next thing you‚Äôll notice is that all the code is wrapped with a <code>repeatUntilCancelled</code>. This is a helper function that will repeat our block infinitely, and make sure it keeps running even in the face of exceptions. It will only stop when the coroutine is cancelled. We‚Äôll use this little trick on our <em>Worker</em> code too. Here‚Äôs the code, courtesy of <a href="https://twitter.com/_fletchr">@_fletchr</a>:</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.isActive
import kotlinx.coroutines.yield
import java.lang.Thread.currentThread

//sampleStart
suspend fun CoroutineScope.repeatUntilCancelled(block: suspend () -> Unit) {
    while (isActive) {
        try {
            block()
            yield()
        } catch (ex: CancellationException) {
            println("coroutine on ${currentThread().name} cancelled")
        } catch (ex: Exception) {
            println("${currentThread().name} failed with {$ex}. Retrying...")
            ex.printStackTrace()
        }
    }
    
    println("coroutine on ${currentThread().name} exiting")
}
//sampleEnd
</xmp>


<p>We have while loop on the <code>isActive</code> property from the CoroutineScope that will guarantee we keep repeating the block until the coroutine is no longer active (i.e. it has been cancelled). We have access to this property because <code>repeatUntilCancelled</code> is an extension function on CoroutineScope.</p>

<p>Having the <em>try/catch</em> guarantees the coroutine will keep looping even if the block throws an exception (like a connection timeout reading messages from the queue, for example). <code>CancellationException</code> is the exception used by the coroutines machinery to signal the cancellation of the coroutine. We handle it as a special case because we don&rsquo;t want to print a message saying <em>&ldquo;Retrying&hellip;&rdquo;</em>, because the while loop is about to break.</p>

<p>The call to <code>yield()</code> is needed to avoid the case where all threads are busy with CPU intensive coroutines that do not suspend, and thus there&rsquo;s no chance for other coroutines to execute.</p>

<p>Ok, back to our <code>launchMsgReceiver</code> function!  The next part is the actual polling for messages. You‚Äôll notice that I‚Äôm maxing out the <code>waitTimeSeconds</code>  so the call waits up to <em>20 seconds</em>, for at least one message to be available before returning empty. I‚Äôm also picking the biggest value for the number of messages being retrieved at once (10), because the whole point of my consumer is to be able to process as many of them in parallel, as possible.</p>

<p>Next line is the <code>receiveMessage</code> call on the SQS client. One extremely important detail is that <strong>I‚Äôm using the <code>SqsAsyncClient</code> from <a href="https://github.com/aws/aws-sdk-java-v2">AWS Java SDK v2</a></strong>. Why? Because I don‚Äôt want my thread to be blocked waiting for messages to appear. And the <code>SqsAsyncClient</code> of Java SKD v1 returns only a <code>Future</code> (because it needs to be compatible with Java 1.6) making it harder to integrate with the coroutines world. Instead, the new version returns <code>CompletableFuture</code>, which lets us call <code>await()</code> (from <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-jdk8/">Kotlinx Coroutines JDK8</a>) to suspend our coroutine until the result is ready <strong>without blocking the thread</strong>.</p>

<p>Finally we iterate over the messages and send them through the channel using  <code>channel.send(it)</code> . Because of the way <a href="https://kotlinlang.org/docs/reference/coroutines/channels.html">unbuffered channels</a> work the <code>send</code> call will suspend if there is no worker available to receive the message. This is a very nice property because it means <strong>we get <a href="https://medium.com/@jayphelps/backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7"><em>backpressure</em></a> for free</strong>. If at some point our workers are not able to process the messages fast enough, the <em>MsgReceiver</em> will just wait (suspend) until some worker becomes available, instead of fetching even more messages, drowning the workers.</p>

<h3>Worker</h3>

<p>Now let‚Äôs take a look at the worker that will process the messages:</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
 private fun CoroutineScope.launchWorker(channel: ReceiveChannel<Message>) = launch {
        repeatUntilCancelled {
            for (msg in channel) {
                try {
                    processMsg(msg)
                    deleteMessage(msg)
                } catch (ex: Exception) {
                    println("${Thread.currentThread().name} exception trying to process message ${msg.body()}")
                    ex.printStackTrace()
                    changeVisibility(msg)
                }
            }
        }
    }
</xmp>


<p>The first lines are pretty similar to the <em>MsgReceiver</em>. We‚Äôre again launching a coroutine and not waiting for it to complete, and thus we have the <code>launch</code> call and our function is an extension of <code>CoroutineScope</code>. We‚Äôre also wrapping everything in a <code>repeatUntilCancelled</code> for the same reasons we used it before. The only difference you might notice is that it takes a <code>ReceiveChannel</code> instead of <code>SendChannel</code>, because this is the receiving end of the communication.</p>

<p>Next we use a <code>for</code> loop to consume messages from the channel. It will suspend the coroutine if there are no new messages in the channel. The use of <code>for</code> is important because we‚Äôre doing <a href="https://kotlinlang.org/docs/reference/coroutines/channels.html#fan-out">fan-out</a>, we have multiple coroutines consuming from the same channel. Consuming with <code>for</code> guarantees us that if one coroutine fails it won‚Äôt cancel the underlying channel, which is what would happen if we had used <code>consumeEach</code> to go through the messages, instead.</p>

<p>Also channels have the nice property of <a href="https://kotlinlang.org/docs/reference/coroutines/channels.html#channels-are-fair">being fair</a>. Meaning that the first coroutine that invoke <code>receive</code> gets the message. FIFO style.</p>

<p>If something fails while processing the message we (try to) <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-visibility-timeout.html">change the visibility timeout</a> so that the message will show up in the queue again sooner, and picked up for re-processing.</p>

<p>Let‚Äôs now take a look at <em>processMessage(msg)</em> implementation:</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
private suspend fun processMsg(message: Message) {
        println("${Thread.currentThread().name} Started processing message: ${message.body()}")
        delay((1000L..2000L).random())
        println("${Thread.currentThread().name} Finished processing of message: ${message.body()}")
    }
</xmp>


<p>As you can tell, this is a mock implementation. There‚Äôs nothing interesting happening here. We just <code>delay</code> for a few seconds and then continue saying that message has been processed. This is where you‚Äôd put your actual logic. Or better yet, if you plan to reuse your SQS consumer implementation <strong>you might want to turn this into a Lambda expression that can be passed as a parameter</strong>.</p>

<p>Finally let‚Äôs see <em>deleteMsg(msg)</em> and <em>changeVisibility(msg)</em>:</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
private suspend fun deleteMessage(message: Message) {
        sqs.deleteMessage { req ->
            req.queueUrl(SQS_URL)
            req.receiptHandle(message.receiptHandle())
        }.await()
        println("${Thread.currentThread().name} Message deleted: ${message.body()}")
    }
    
    private suspend fun changeVisibility(message: Message) {
        sqs.changeMessageVisibility { req ->
            req.queueUrl(SQS_URL)
            req.receiptHandle(message.receiptHandle())
            req.visibilityTimeout(10)
        }.await()
        println("${Thread.currentThread().name} Changed visibility of message: ${message.body()}")
    }
</xmp>


<p>This 2 methods follow the same pattern: call the <code>SQSAsyncClient</code> corresponding method then <code>await()</code>, finally log.</p>

<h3>Contexts, dispatchers and supervisors</h3>

<p>Now that we have a good grasp on the different parts of our solution, let‚Äôs pay closer attention to how the coroutines are created and dispatched.</p>

<p>One of the central tenets of Kotlin coroutines is <em><a href="https://kotlinlang.org/docs/reference/coroutines/basics.html#structured-concurrency">structured concurrency</a></em>. <em>Structured concurrency</em> helps us write code that properly cleans up active coroutines in case of exceptions. If you think you‚Äôre a hardcore developer and instead launch your coroutines using <code>GlobalScope.launch { ... }</code>, then you risk leaking coroutines when something fails (check <a href="https://twitter.com/relizarov">@relizarov</a>‚Äôs <a href="https://medium.com/@elizarov/structured-concurrency-722d765aa952">article</a> to see an example of this). So, how‚Äôs are our coroutines structured?</p>

<p>{% img center /images/posts/2019-03-10/coroutinesScope.png 400 ‚Äòcoroutines structure‚Äô %}</p>

<p>To mark the lifecycle of our coroutines we extend our class with <code>CoroutineScope</code> and provide a context by overriding <code>corroutinesContext: CorroutineContext</code>. This is the context that‚Äôll be used by our root coroutine, the one started by the <code>launch</code> call on the <code>start()</code> function, at the beginning of this post. Since we want our coroutines to match the lifecycle of our class we‚Äôve added a <code>close()</code> method that clients can call to cancel all the coroutines in the consumer. If you‚Äôre using some kind of framework you might want to tie this function the lifecycle of the class in some other way.</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
package com.jivimberg.sqs

import kotlinx.coroutines.\*
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.channels.ReceiveChannel
import kotlinx.coroutines.channels.SendChannel
import kotlinx.coroutines.future.await
import software.amazon.awssdk.regions.Region
import software.amazon.awssdk.services.sqs.SqsAsyncClient
import software.amazon.awssdk.services.sqs.model.Message
import software.amazon.awssdk.services.sqs.model.ReceiveMessageRequest
import kotlin.coroutines.CoroutineContext

//sampleStart

class SqsSampleConsumerChannels(
        private val sqs: SqsAsyncClient
) : CoroutineScope {

    private val supervisorJob = SupervisorJob()
    override val coroutineContext: CoroutineContext
        get() = Dispatchers.IO + supervisorJob
    
    fun start() = launch {
        val messageChannel = Channel<Message>()
        repeat(N_WORKERS) { launchWorker(messageChannel) }
        launchMsgReceiver(messageChannel)
    }
    
    fun stop() {
        supervisorJob.cancel()
    }

//sampleEnd

    private fun CoroutineScope.launchMsgReceiver(channel: SendChannel<Message>) = launch {
        repeatUntilCancelled {
            val receiveRequest = ReceiveMessageRequest.builder()
                    .queueUrl(SQS_URL)
                    .waitTimeSeconds(20)
                    .maxNumberOfMessages(10)
                    .build()
    
            val messages = sqs.receiveMessage(receiveRequest).await().messages()
            println("${Thread.currentThread().name} Retrieved ${messages.size} messages")
    
            messages.forEach {
                channel.send(it)
            }
        }
    }
    
    private fun CoroutineScope.launchWorker(channel: ReceiveChannel<Message>) = launch {
        repeatUntilCancelled {
            for (msg in channel) {
                try {
                    processMsg(msg)
                    deleteMessage(msg)
                } catch (ex: Exception) {
                    println("${Thread.currentThread().name} exception trying to process message ${msg.body()}")
                    ex.printStackTrace()
                    changeVisibility(msg)
                }
            }
        }
    }
    
    private suspend fun processMsg(message: Message) {
        println("${Thread.currentThread().name} Started processing message: ${message.body()}")
        delay((1000L..2000L).random())
        println("${Thread.currentThread().name} Finished processing of message: ${message.body()}")
    }
    
    private suspend fun deleteMessage(message: Message) {
        sqs.deleteMessage { req ->
            req.queueUrl(SQS_URL)
            req.receiptHandle(message.receiptHandle())
        }.await()
        println("${Thread.currentThread().name} Message deleted: ${message.body()}")
    }
    
    private suspend fun changeVisibility(message: Message) {
        sqs.changeMessageVisibility { req ->
            req.queueUrl(SQS_URL)
            req.receiptHandle(message.receiptHandle())
            req.visibilityTimeout(10)
        }.await()
        println("${Thread.currentThread().name} Changed visibility of message: ${message.body()}")
    }
}

fun main() = runBlocking {
    println("${Thread.currentThread().name} Starting program")
    val sqs = SqsAsyncClient.builder()
            .region(Region.US_EAST_1)
            .build()
    val consumer = SqsSampleConsumerChannels(sqs)
    consumer.start()
    delay(30000)
    consumer.stop()
}

private const val N\_WORKERS = 4
</xmp>


<p>Our <code>coroutineContext</code> has 2 elements: the <code>Dispatcher</code> and the <code>supervisorJob</code> (<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-coroutine-context/plus.html">the <code>+</code> operation</a> concatenates both elements in a new <code>CoroutineContext</code> ).</p>

<p>The <em>Dispatcher</em> marks which thread our coroutine will run on. In our case I used <code>Dispatchers.IO</code> that uses a shared pool of threads for doing IO (more details <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-i-o.html">here</a>). This is because most of the time my coroutines are doing IO operations for: receiving messages, deleting them, changing visibility, etc. If, in your case, processing a message requires a CPU intensive calculation you‚Äôd use <code>Dispatchers.Default</code> through the <code>withContext</code> function like this:</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
private suspend fun processMsg(message: Message) = withContext(Dispatchers.Default) {
        // Your code here
    }
</xmp>


<h2>In case of exception</h2>

<p>Because we‚Äôre responsible developers, let‚Äôs see what would happen if something were to fail.</p>

<p>As a first line of defense we know both our <em>Workers</em> and the <em>MsgReceiver</em> are running in <code>repeatUntilCancelled</code> loops, so any exception should be logged and ignored. This is ok for us because once the visibility timeout is over, the message will re-appear in the queue for another worker to consume. Still, to be extra careful, let‚Äôs consider what would happen with our coroutines in case of exception if we didn‚Äôt have <code>repeatUntilCancelled</code>s.</p>

<p>The whole premise of <a href="https://kotlinlang.org/docs/reference/coroutines/basics.html#structured-concurrency">structured concurrency</a> is to avoid leaking coroutines in case of failure. That‚Äôs why, by default, <strong>whenever a child coroutine terminates with exception its parent and siblings are cancelled too</strong>. This is a nice property, but not quite what we want in this case. We don‚Äôt want all workers to be cancelled because one worker threw an exception. That‚Äôs why we use <code>supervisorJob</code> as part of our <code>coroutineContext</code>. <a href="https://kotlinlang.org/docs/reference/coroutines/exception-handling.html#supervision-job">SupervisorJob</a> is like a regular job, with the exception that cancellation is propagated only downwards.</p>

<p>{% img center /images/posts/2019-03-10/Supervisor.png 600 ‚ÄòRegular Job vs. Supervisor Job‚Äô %}</p>

<p>Finally, don‚Äôt forget to configure a <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html">dead letter queue</a> for those messages that can‚Äôt be processed even after multiple retries.</p>

<hr />

<p>That‚Äôs all! You can find all the code from this post in <a href="https://gist.github.com/jivimberg/b0f4f94871c6f3e7d17fae1106c28047">this gist</a>. If you have any improvement to suggest, I‚Äôd ‚ù§Ô∏è to hear about it. Leave me a comment down there.</p>

<p>{% img right-fill /images/signatures/signature11.png 200 ‚ÄòMy signature‚Äô %}</p>

<script src="https://unpkg.com/kotlin-playground@1" data-selector=".kotlin-code"></script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using UUID on Spring Data JPA Entities]]></title>
    <link href="http://jivimberg.github.io/blog/2018/11/05/using-uuid-on-spring-data-jpa-entities/"/>
    <updated>2018-11-05T07:25:37-08:00</updated>
    <id>http://jivimberg.github.io/blog/2018/11/05/using-uuid-on-spring-data-jpa-entities</id>
    <content type="html"><![CDATA[<p>In this article I‚Äôll explore <strong>how to model a <a href="https://stackoverflow.com/questions/6033905/create-the-perfect-jpa-entity">JPA Entity</a> using an <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a></strong> as Primary Key working with <a href="https://spring.io/projects/spring-data-jpa">Spring Data JPA.</a></p>

<!--more-->


<p>{% img center /images/posts/2018-11-07/uuid.png ‚Äòuuid key‚Äô %}</p>

<h1>Why UUIDs?</h1>

<p>Usually we use numerical keys on our models and let the DB generate that for us on persistence. But there are <strong>some reasons why you might prefer to use UUIDs</strong> as your Primary Key instead. Namely:</p>

<ul>
<li><strong>UUIDs are globally unique.</strong> This means that we don‚Äôt need a centralized component to generate unique ids, <strong>we can generate the ids on the application itself</strong> instead of relying on <a href="https://vladmihalcea.com/hibernate-and-uuid-identifiers/">some UUID generator</a> that populates the <code>id</code> field on persist.</li>
<li>Having globally unique ids also means that <strong>your ids are unique across databases.</strong> This allows us to move data across databases without having to check for conflicting ids.</li>
<li>Having application generated ids means the id is known even before the entity is persisted. This lets us <strong>model our entities as <a href="https://proandroiddev.com/kotlin-for-beginners-immutability-and-the-value-of-val-78ab45b60b57">immutable objects</a></strong> and we avoid having to handle null values on the id.</li>
</ul>


<p>But as you probably already know: <a href="https://en.wikipedia.org/wiki/There_ain't_no_such_thing_as_a_free_lunch">üö´üÜìüçΩ</a>. So here are some of the downsides of using UUIDss for you to consider:</p>

<ul>
<li><strong>Storage space.</strong> As you can imagine storing an UUID takes a lot more space than storying an Int. Specially if you make the mistake of storing it as a <code>String</code>. You might think Id space is not a big deal, but consider that <strong>Primary Keys are often used in indexes and as Foreign Keys on other tables</strong>. So the numbers start to add up.</li>
<li>They are <strong>not human friendly</strong>. What‚Äôs easier to remember: <code>223492</code> or <code>453bd9d7-83c0-47fb-b42e-0ab045b29f83¬†</code>? This is specially true if you happen to be exposing your ids on your public APIs. Think: <code>/albums/2311445/photo/7426321</code> vs <code>/albums/b3480d79-e458-4675-a7ba-61ac5957cb7c/photo/19b24967-1741-4405-a746-d2b081ee45f2¬†</code>.</li>
</ul>


<p><strong>If you‚Äôre still on the fence</strong> here‚Äôs a great article talking about the pros and cons of using UUIDs as primary keys: <a href="https://tomharrisonjr.com/uuid-or-guid-as-primary-keys-be-careful-7b2aa3dcb439">https://tomharrisonjr.com/uuid-or-guid-as-primary-keys-be-careful-7b2aa3dcb439</a>.</p>

<h1>How to do it</h1>

<p>Now let‚Äôs talk about how we can implement this. I‚Äôll go step by step explaining why we add each piece of code.</p>

<p>The first thing we need to do is <strong>generate the UUID</strong>. As mentioned above we‚Äôd like to do this on the application code so we can have <em>immutable entities</em>. Generating the UUID is easy, all we need to do is: <code>UUID.randomUUID()</code>. So our entity would look like this:</p>

<xmp class="kotlin-code" theme="darcula" data-highlight-only>
import java.util.\*
import javax.persistence.Id
import javax.persistence.Entity

//sampleStart
@Entity
class Artist(
        @Id val id: UUID = UUID.randomUUID(),
        val name: String
)
//sampleEnd
</xmp>


<p>You‚Äôve probably noticed how we‚Äôre making the id an argument of the <a href="https://kotlinlang.org/docs/reference/classes.html#constructors">primary constructor</a>. This is required to <strong>let clients construct entities with known ids to represent persisted objects</strong>. This is useful for example to <strong>model an update operation</strong>: create an enwtity with a known id and updated values, then call <code>save()</code> on such entity.</p>

<h2>isNew?</h2>

<p>As mentioned we‚Äôre using <a href="https://spring.io/projects/spring-data-jpa">Spring Data JPA</a> for our Repository layer. Now there‚Äôs a small detail we have to take into account when <strong>using application provided ids with Spring Data</strong>. If you do a <code>artistRepository.save(Artist(name = "David Bowie"))</code> you might get an output like this:</p>

<p>{% img center /images/posts/2018-11-07/2sql.png ‚Äòpersist logs‚Äô %}</p>

<p>If you pay close attention to the log you‚Äôll notice that <strong>Hibernate is actually executing 2 SQL queries</strong>: one <code>select</code> followed by one <code>insert</code>. Not quite what we were expecting.</p>

<p>The reason for this behavior is the implementation of Spring Data‚Äôs <a href="https://github.com/spring-projects/spring-data-jpa/blob/master/src/main/java/org/springframework/data/jpa/repository/support/SimpleJpaRepository.java"><code>SimpleJpaRepository.java</code></a>. In particular the <a href="https://github.com/spring-projects/spring-data-jpa/blob/01e36dbb44d6bc87f7deb3b6d6dacc955ea6c8bd/src/main/java/org/springframework/data/jpa/repository/support/SimpleJpaRepository.java#L506"><code>save()</code></a> method:</p>

<pre><code class="java">@Transactional
public &lt;S extends T&gt; S save(S entity) {
    if (entityInformation.isNew(entity)) {
        em.persist(entity);
        return entity;
    } else {
        return em.merge(entity);
    }
}
</code></pre>

<p><strong>The double SQL statement is caused by the call to <code>merge()</code></strong>. By default the way this class decides whether to do a <code>persist()</code> or a <code>merge()</code> <strong>is simply by checking if the id is null</strong>. Which works fine for DB assigned ids, but <em>not</em> for application assigned ones. üòï</p>

<p><strong>The best way to control this is by implementing the <a href="https://github.com/spring-projects/spring-data-commons/blob/master/src/main/java/org/springframework/data/domain/Persistable.java"><code>Persistable&lt;ID&gt;</code></a> interface</strong> providing a <code>isNew()</code> method. Since this is something we‚Äôll want to do every time we use application generated UUIDs <strong>I‚Äôll extract this into an abstract class</strong> and making use of the <code>@MappedSuperClass</code> annotation.</p>

<xmp class="kotlin-code" theme="darcula" data-highlight-only>
import org.springframework.data.domain.Persistable
import java.util.\*
import javax.persistence.\*

//sampleStart
@MappedSuperclass
abstract class AbstractBaseEntity(givenId: UUID? = null) : Persistable<UUID> {

    @Id
    @Column(name = "id", length = 16, unique = true, nullable = false)
    private val id: UUID = givenId ?: UUID.randomUUID()
    
    @Transient
    private var persisted: Boolean = givenId != null
    
    override fun getId(): UUID = id
    
    override fun isNew(): Boolean = !persisted
    
    override fun hashCode(): Int = id.hashCode()
    
    override fun equals(other: Any?): Boolean {
        return when {
            this === other -> true
            other == null -> false
            other !is AbstractBaseEntity -> false
            else -> getId() == other.getId()
        }
    }
    
    @PostPersist
    @PostLoad
    private fun setPersisted() {
        persisted = true
    }
}
//sampleEnd

</xmp>


<blockquote><p>This design was <strong>suggested to me by <a href="https://twitter.com/PabloHernanS">@paschmid</a> and <a href="https://twitter.com/rcruzjo">@rcruzjo</a></strong>, this code would be quite ugly if it weren‚Äôt for them!</p></blockquote>

<p>You can see how the <code>persisted</code> state is decided based on whether an id is provided on creation or not, to account for updates. Also notice how <strong>its value gets automatically updated upon <em>persist</em> and <em>load</em></strong> thanks to <code>@PostPersist</code> and <code>@PostLoad</code> annotations.</p>

<p>Also since <code>id</code> is now <em>unique</em> and <em>non-nullable</em> <strong>we can use it to implement <code>equals()</code> and <code>hashcode()</code></strong> and avoid falling in some of the common pitfalls of implementing this methods (to learn more about this check <a href="https://vladmihalcea.com/how-to-implement-equals-and-hashcode-using-the-jpa-entity-identifier/">this article</a> by <a href="https://twitter.com/vlad_mihalcea">@vlad_mihalcea</a> and <a href="https://kotlinexpertise.com/hibernate-with-kotlin-spring-boot/">this one</a> by <a href="https://twitter.com/s1m0nw1">@s1m0nw1</a>).</p>

<p>And in case you‚Äôre wondering <strong>why we need an explicit <code>getId()</code> function</strong>, it is because of this issue: <a href="https://youtrack.jetbrains.com/issue/KT-6653">Kotlin properties do not override Java-style getters and setters</a>.</p>

<h1>Putting it all together</h1>

<p>Finally let‚Äôs see how a concrete entity would use this.</p>

<xmp class="kotlin-code" theme="darcula" data-highlight-only>
import org.springframework.data.repository.CrudRepository
import java.util.\*
import javax.persistence.Entity

//sampleStart
@Entity
class Artist(
        id: UUID? = null,
        val name: String
) : AssignedIdBaseEntity(id)
//sampleEnd
</xmp>


<p>Pretty similar to our original approach right? Thanks to the abstract class all the <code>isNew()</code> <strong>implementation details are hidden</strong> from concrete entities.</p>

<p>And now if we do a <code>save()</code> on a new entity <strong>we get one single SQL statement</strong> as we were expecting.</p>

<p>{% img center /images/posts/2018-11-07/1sql.png 600 ‚Äòpersist logs with abstractEntity‚Äô %}</p>

<hr />

<h1>Approach 2: Making it simpler with @Version</h1>

<p>This approach was suggested by <a href="https://disqus.com/by/disqus_UhNaTY8OWI/">Diego Marin</a> in the comments.</p>

<p>Spring Data can leverage the existence of a <code>@Version</code> field to tell if the Entity is present or not. By having <code>@Version</code>, we also get <a href="https://www.baeldung.com/jpa-optimistic-locking">Optimistic Locking</a> for free.</p>

<xmp class="kotlin-code" theme="darcula" data-highlight-only>
import java.util.*
import javax.persistence.Column
import javax.persistence.Entity
import javax.persistence.Id
import javax.persistence.Version

//sampleStart
@Entity
class Celeb(
        @Id @Column(name = "id", length = 16, unique = true, nullable = false)
        val id: UUID = UUID.randomUUID(),
        @Version
        val version: Long? = null,
        val name: String
) {
    override fun equals(other: Any?) = when {
        this === other -> true
        javaClass != other?.javaClass -> false
        id != (other as Celeb).id -> false
        else -> true
    }

    override fun hashCode(): Int = id.hashCode()
}
//sampleEnd
</xmp>


<blockquote><p>‚ö†Ô∏è Make sure you‚Äôre importing <code>javax.persistence.Version</code> and NOT <code>org.springframework.data.annotation.Version</code>!</p></blockquote>

<p>We still need to write the <code>id</code> column definition and <code>equal</code> and <code>hashCode</code> methods, so if this is something you‚Äôll be applying in most of your entities you might want to consider extracting it to a superclass. Similar to what we did with <code>AssignedIdBaseEntity</code>, but using <code>@Version</code></p>

<hr />

<p>You can find all the <strong>code samples</strong> for this post on <strong><a href="https://github.com/jivimberg/spring-data-uuid-example">this GitHub repo</a></strong>.</p>

<p>{% img right-fill /images/signatures/signature1.png 200 ‚ÄòMy signature‚Äô %}</p>

<script src="https://unpkg.com/kotlin-playground@1" data-selector=".kotlin-code"></script>



]]></content>
  </entry>
  
</feed>
