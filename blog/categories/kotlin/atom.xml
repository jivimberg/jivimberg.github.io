<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Kotlin | Coding Forest]]></title>
  <link href="http://jivimberg.github.io/blog/categories/kotlin/atom.xml" rel="self"/>
  <link href="http://jivimberg.github.io/"/>
  <updated>2018-06-24T15:40:37-07:00</updated>
  <id>http://jivimberg.github.io/</id>
  <author>
    <name><![CDATA[Juan Ignacio Vimberg]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Oracle, JPA and the Mystery of the String That Was Null]]></title>
    <link href="http://jivimberg.github.io/blog/2018/06/23/oracle-jpa-and-the-mistery-of-the-string-that-was-null/"/>
    <updated>2018-06-23T10:34:26-07:00</updated>
    <id>http://jivimberg.github.io/blog/2018/06/23/oracle-jpa-and-the-mistery-of-the-string-that-was-null</id>
    <content type="html"><![CDATA[<p>This is the story of how Oracle DB was messing up Kotlin‚Äôs type system, and what I did to fix it.</p>

<!--more-->


<h2>The setup</h2>

<p>Let‚Äôs start by <em>setting the stage</em>, for this particular project I was working with the following stack:</p>

<p><a href="https://developers.redhat.com/promotions/migrating-to-microservice-databases/"><img class="center" src="/images/posts/2018-06-23/Stack.png" width="720" title="‚ÄôSpring + Data + Kotlin + Oracle‚Äô" ></a></p>

<h2>The problem</h2>

<p>So I had modeled the following <strong>Entity</strong> leveraging Kotlin‚Äôs <a href="https://kotlinlang.org/docs/reference/data-classes.html">data classes</a><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>:</p>

<xmp class="kotlin-code" data-highlight-only>
import javax.persistence.Entity
import javax.persistence.Id

//sampleStart
@Entity
data class Person(
    val name: String,
    @Id val id: Long? = null
)
//sampleEnd
</xmp>


<p>Tests where passing with flying colors, but for some reason we were noticing that <strong>the <em>name</em> would sometimes come back as <code>null</code></strong> even thought it was typed as <code>String</code> and not <code>String?</code>.</p>

<h2>The analysis</h2>

<p>To make things more difficult there where other failures in the communication layer masking the real issue. But we finally figured out what was happening when we notice <strong>it was only reproducible under the following conditions</strong>:</p>

<ul>
<li>The property <code>name</code> was empty</li>
<li>Not reproducible on tests</li>
<li>Persisting to <em>OracleDB</em> (instead of embedded H2)</li>
</ul>


<p>That‚Äôs when I discovered:
<blockquote><p>This is because Oracle internally changes empty string to NULL values. Oracle simply won&rsquo;t let insert an empty string.</p><footer><strong>Some guy on Stack Overflow <a href="https://stackoverflow.com/a/13278879/1499171">https://stackoverflow.com/a/13278879/1499171</a></strong></footer></blockquote></p>

<p>So when the data was mapped back to my <code>Person</code> object I ended up with a <code>null</code> value for <em>name</em>. This is probably only possible because <strong>Hibernate is using reflection to set the field value</strong> in runtime, thus breaking Kotlin‚Äôs <a href="https://kotlinlang.org/docs/reference/null-safety.html">null safety</a>.</p>

<h2>What I did about it</h2>

<p>The funny thing about this one is that <strong>there is not much you can do about it</strong>. <em>There is no magic configuration to tell Oracle how you want to handle empty strings.</em> Yes there are some hacks like changing <code>""</code> to <code>" "</code> but I‚Äôd rather invent a random <em>name</em> for the guy than persisting a whitespace.</p>

<p>The silver lining is that most of the time <strong>if you‚Äôre not allowing null values you probably don‚Äôt want an empty string either</strong>. Now YMMV but I know this was true for a person‚Äôs name.</p>

<p>In fact you might even want to <strong>implement a more strict validation</strong> so people can‚Äôt be named: ‚Äúüí©‚Äù.</p>

<h3>Testing</h3>

<p>First thing I did was to try to reproduce this using a test. But since I was using <code>@DataJpaTest</code> with H2 embedded DB empty strings where empty strings an nulls where nulls. So the issue was <strong>not reproducible</strong>.</p>

<p>That‚Äôs when I learned that you <strong>can tell H2 to behave like an Oracle DB</strong> using <a href="http://www.h2database.com/html/features.html">Oracle Compatibility mode</a>. To achieve this I added the following configuration to my <code>application.yml</code> under <code>test/resources</code>:</p>

<pre><code>spring:
  datasource:
    url: jdbc:h2:mem:testdb;Mode=Oracle
</code></pre>

<p>And annotated my test class with:</p>

<pre><code class="java">@RunWith(SpringRunner::class)
@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
class FormRepositoryTest {‚Ä¶}
</code></pre>

<p>And <em>voil√†</em>, now you have an <strong>H2 in memory DB dressed up as Oracle</strong>.</p>

<h3>Changing the schema</h3>

<p>The other thing I realized is that <strong>the schema allowed for <code>null</code> values</strong> on the <em>name</em> column. I‚Äôd been using <code>javax.persistence.schema-generation</code> as a starting point for my schema and <strong>I wrongly assumed</strong> it would take the hint from the Kotlin type system to prevent null values<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>.</p>

<p>Instead I had to explicitly annotate my Entity:</p>

<xmp class="kotlin-code" data-highlight-only>
import javax.persistence.Entity
import javax.persistence.Id

//sampleStart
@Entity
data class Person(
    @Column(nullable = false) val name: String,
    @Id val id: Long? = null
)
//sampleEnd
</xmp>


<p>and manually change my existing schema</p>

<pre><code>CREATE TABLE Person (
  id NUMBER(19, 0) NOT NULL,
  name VARCHAR2(255 CHAR) NOT NULL,
  PRIMARY KEY (id)
);
</code></pre>

<p>The result is that now if somebody tries to persist a Person with an empty name a <strong>big fat Exception is thrown</strong>. Or at least until I implement proper name validation.</p>

<script src="https://unpkg.com/kotlin-playground@1" data-selector=".kotlin-code"></script>



<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>If I had a dollar for every time I modeled a Person‚Ä¶<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>It would be nice right?<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implementing takeWhileInclusive in Kotlin]]></title>
    <link href="http://jivimberg.github.io/blog/2018/06/02/implementing-takewhileinclusive-in-kotlin/"/>
    <updated>2018-06-02T13:33:38-07:00</updated>
    <id>http://jivimberg.github.io/blog/2018/06/02/implementing-takewhileinclusive-in-kotlin</id>
    <content type="html"><![CDATA[<p>Implementing <code>takeWhileInclusive</code> extension function in Kotlin.</p>

<!--more-->


<blockquote><p>TL,DR (aka <em>‚Äújust show me the code‚Äù</em> ): <a href="https://gist.github.com/jivimberg/ff5aad3f5c6315deb420fd508a145c61">https://gist.github.com/jivimberg/ff5aad3f5c6315deb420fd508a145c61</a></p></blockquote>

<p>You probably know about <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take-while.html"><code>takeWhile</code></a> operation that <strong>returns a List containing the first elements satisfying the given predicate.</strong></p>

<xmp class="kotlin-code">
fun main(args: Array<String>) {
//sampleStart
    val someNumbers = listOf(1, 5, 3, 22, 4, 8, 14, 23, 49, 77, 2, 49)
    println(someNumbers.takeWhile { it % 7 != 0 })
//sampleEnd
}
</xmp>


<p>I was in need of an <strong>inclusive</strong> version of the <code>takeWhile</code>. In other words I needed a function that returned the first elements satisfying the given predicate, <strong>plus the first element that didn‚Äôt satisfy it</strong>.</p>

<p>So in the provided example <code>takeWhile</code> returns <code>[1, 5, 3, 22, 4, 8]</code> whereas <code>takeWhileInclusive</code> would return <code>[1, 5, 3, 22, 4, 8, 14]¬†</code> .</p>

<p>A quick search showed me I was not alone. <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take-while.html"><em>matklad</em></a> already had a simple implementation working for <code>Sequence</code>:</p>

<p><div><script src='https://gist.github.com/54776705250e3b375618f59a8247a237.js'></script>
<noscript><pre><code>fun &lt;T&gt; Sequence&lt;T&gt;.takeWhileInclusive(pred: (T) -&gt; Boolean): Sequence&lt;T&gt; {
    var shouldContinue = true
    return takeWhile {
        val result = shouldContinue
        shouldContinue = pred(it)
        result
    }
}
</code></pre></noscript></div>
</p>

<p>Using <strong>extension functions</strong> we are able to add a new function to the standard library type <code>Sequence</code>. If this is your first encounter with an extension function I‚Äôd encourage you to read more about them <a href="https://kotlinlang.org/docs/reference/extensions.html#extension-functions">here</a> and then play with them <a href="https://try.kotlinlang.org/#/Kotlin%20Koans/Introduction/Extension%20functions/Task.kt">here</a>.</p>

<p>I found this implementation of <code>takeWhileInclusive</code> quite <strong>elegant</strong>. It uses the original <code>takeWhile</code> with the given predicated, but keeps a <code>shouldContinue</code> variable to delay the predicate evaluation by one step. In other words the evaluation of the predicate passed to <code>takeWhile</code> on element <em>i</em> will actually be the result of applying the predicate function on <em>i - 1</em>. Which if you think about it <em>is exactly what we need</em>. Let‚Äôs give it a try:</p>

<xmp class="kotlin-code">
fun <T> Sequence<T>.takeWhileInclusive(
        predicate: (T) -> Boolean
): Sequence<T> {
    var shouldContinue = true
    return takeWhile {
        val result = shouldContinue
        shouldContinue = predicate(it)
        result
    }
}

fun main(args: Array<String>) {
//sampleStart
   val someNumbers = listOf(1, 5, 3, 22, 4, 8, 14, 23, 49, 77, 2, 49).asSequence()
   println(someNumbers.takeWhileInclusive { it % 7 != 0 }.toList())
//sampleEnd
}
</xmp>


<p>This was good! Only <a href="https://gist.github.com/matklad/54776705250e3b375618f59a8247a237#gistcomment-2093675">this comment</a> posted on the original gist made me doubt about the <em>safety</em> of this approach:</p>

<blockquote><p><em>‚ÄúI love this. If Sequence were parallel, though, wouldn&rsquo;t there be worries about using out-of-closure state?‚Äù</em></p></blockquote>

<p>That send me down the rabbit hole and I spent some days reading about <code>parallelStreams</code> and <code>coroutines</code> until I convinced my self the approach was ok.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<p>With that out of the way I decided to port this solution to be supported in all the places where the <code>takeWhile</code> exists (including <code>String</code> and <code>CharArray</code>). So that <strong>we don‚Äôt have to convert to a from a Sequence just to use this function</strong>.</p>

<p>Here‚Äôs the end result, ready to be dropped on your project:</p>

<p><div><script src='https://gist.github.com/ff5aad3f5c6315deb420fd508a145c61.js'></script>
<noscript><pre><code>// kotlin.collections

inline fun &lt;T&gt; Array&lt;out T&gt;.takeWhileInclusive(
        predicate: (T) -&gt; Boolean
): List&lt;T&gt; {
    var shouldContinue = true
    return takeWhile {
        val result = shouldContinue
        shouldContinue = predicate(it)
        result
    }
}

inline fun ByteArray.takeWhileInclusive(
        predicate: (Byte) -&gt; Boolean
): List&lt;Byte&gt; {
    var shouldContinue = true
    return takeWhile {
        val result = shouldContinue
        shouldContinue = predicate(it)
        result
    }
}

inline fun ShortArray.takeWhileInclusive(
        predicate: (Short) -&gt; Boolean
): List&lt;Short&gt; {
    var shouldContinue = true
    return takeWhile {
        val result = shouldContinue
        shouldContinue = predicate(it)
        result
    }
}

inline fun IntArray.takeWhileInclusive(
        predicate: (Int) -&gt; Boolean
): List&lt;Int&gt; {
    var shouldContinue = true
    return takeWhile {
        val result = shouldContinue
        shouldContinue = predicate(it)
        result
    }
}

inline fun LongArray.takeWhileInclusive(
        predicate: (Long) -&gt; Boolean
): List&lt;Long&gt; {
    var shouldContinue = true
    return takeWhile {
        val result = shouldContinue
        shouldContinue = predicate(it)
        result
    }
}

inline fun FloatArray.takeWhileInclusive(
        predicate: (Float) -&gt; Boolean
): List&lt;Float&gt; {
    var shouldContinue = true
    return takeWhile {
        val result = shouldContinue
        shouldContinue = predicate(it)
        result
    }
}

inline fun DoubleArray.takeWhileInclusive(
        predicate: (Double) -&gt; Boolean
): List&lt;Double&gt; {
    var shouldContinue = true
    return takeWhile {
        val result = shouldContinue
        shouldContinue = predicate(it)
        result
    }
}

inline fun BooleanArray.takeWhileInclusive(
        predicate: (Boolean) -&gt; Boolean
): List&lt;Boolean&gt; {
    var shouldContinue = true
    return takeWhile {
        val result = shouldContinue
        shouldContinue = predicate(it)
        result
    }
}

inline fun CharArray.takeWhileInclusive(
        predicate: (Char) -&gt; Boolean
): List&lt;Char&gt; {
    var shouldContinue = true
    return takeWhile {
        val result = shouldContinue
        shouldContinue = predicate(it)
        result
    }
}

inline fun &lt;T&gt; Iterable&lt;T&gt;.takeWhileInclusive(
        predicate: (T) -&gt; Boolean
): List&lt;T&gt; {
    var shouldContinue = true
    return takeWhile {
        val result = shouldContinue
        shouldContinue = predicate(it)
        result
    }
}

// kotlin.sequences

fun &lt;T&gt; Sequence&lt;T&gt;.takeWhileInclusive(
        predicate: (T) -&gt; Boolean
): Sequence&lt;T&gt; {
    var shouldContinue = true
    return takeWhile {
        val result = shouldContinue
        shouldContinue = predicate(it)
        result
    }
}

// kotlin.text

inline fun CharSequence.takeWhileInclusive(
        predicate: (Char) -&gt; Boolean
): CharSequence {
    var shouldContinue = true
    return takeWhile {
        val result = shouldContinue
        shouldContinue = predicate(it)
        result
    }
}

inline fun String.takeWhileInclusive(
        predicate: (Char) -&gt; Boolean
): String {
    var shouldContinue = true
    return takeWhile {
        val result = shouldContinue
        shouldContinue = predicate(it)
        result
    }
}</code></pre></noscript></div>
</p>

<p>Hope you find this useful!</p>

<script src="https://unpkg.com/kotlin-playground@1" data-selector=".kotlin-code"></script>



<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>If you want to read more about my discoveries, check this question at <a href="https://stackoverflow.com/q/50373754/1499171">StackOverflow</a><a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring Functional Routing]]></title>
    <link href="http://jivimberg.github.io/blog/2018/05/20/spring-functional-router/"/>
    <updated>2018-05-20T00:16:22-07:00</updated>
    <id>http://jivimberg.github.io/blog/2018/05/20/spring-functional-router</id>
    <content type="html"><![CDATA[<p>This post is about the clever tricks you can pull with Spring new <strong>functional routing</strong> and it‚Äôs Kotlin DSL.</p>

<!--more-->


<p><img class="center" src="/images/posts/2018-05-19/trainSwitch.jpg" title="‚ÄôTrain switch‚Äô" ></p>

<p>Spring 5 introduced the <a href="https://spring.io/blog/2016/09/22/new-in-spring-5-functional-web-framework">Functional Web Framework</a> and with it the ability to do functional routing. Basically instead of annotating your methods with the good old <code>@RequestMapping</code> you can now write functions that go from a <code>Request</code> to a <code>Response&lt;T&gt;</code> (called <code>HandlerFunction&lt;T&gt;</code>). And then use a <code>RouterFunction&lt;T&gt;</code> to map which path will end up in which handler.</p>

<p>Now, for the sake of brevity, I won‚Äôt talk about all the benefits of this new functional paradigm. Instead I‚Äôd like to focus on <strong>some things that can be done with functional routing that were not possible before</strong>.</p>

<p>I have to admit that <strong>at first</strong> I wasn‚Äôt sold on the functional routing thing. Why would I want to replace <code>@RequestMapping</code> with 2 different functions? Isn‚Äôt that more code to achieve the same goal? For comparison this is how a <em>simple</em> RoutingFunction could look like<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>:</p>

<xmp class="kotlin-code" data-highlight-only>
    fun router() = router {
        accept(TEXT_HTML).nest {
            GET("/") { permanentRedirect(URI("index.html")).build() }
        }
        "/api".nest {
            accept(APPLICATION_JSON).nest {
                GET("/users", userHandler::findAll)
                POST("/users", userHandler::create)
            }
        }
        resources("/**", ClassPathResource("static/"))
    } 
</xmp>


<p>It‚Äôs readable but certainly not as succinct as <code>@GetMapping("/api/users")</code>. But <strong>this terseness comes at the price of expressiveness</strong>. Or as <a href="https://spring.io/blog/2016/09/22/new-in-spring-5-functional-web-framework">this article on Spring.io</a> puts it:</p>

<blockquote><p>The <code>RouterFunction</code> has a similar purpose as a <code>@RequestMapping</code> annotation. However, there is an important distinction: with the annotation <strong>your route is limited to what can be expressed through the annotation values</strong>.</p></blockquote>

<h2>Complex routing</h2>

<p>I‚Äôll use an example to illustrate some of the things that can be achieved with complex routing. Say I have some data modeling a <em>r√©sum√©</em> that contains multiple <em>sections</em>. <strong>I want to expose each of this sections as a different REST endpoint</strong>. Underneath we need to handle each call the same way, the only difference is that we‚Äôd be processing a different <em>section</em> of data. We could do the routing like this:</p>

<xmp class="kotlin-code" data-highlight-only>
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.core.io.ClassPathResource
import org.springframework.http.MediaType
import org.springframework.web.reactive.function.server.RouterFunctions.resources
import org.springframework.web.reactive.function.server.router

//sampleStart
    enum class Section(val fieldName: String) {
    PERSONAL_INFO("personalInfo"),
    EXPERIENCE("experience"),
    SIDE_PROJECTS("sideProject"),
    EDUCATION("education"),
}

@Configuration
class Routing {
    @Bean
    fun resumeRouter(handler: ResumeHandler) = router {
        accept(MediaType.APPLICATION_JSON).nest {
            Section.values().forEach {
                GET("/${it.fieldName}", handler.getSectionHandler(it))
            }
        }
    }
}
//sampleEnd

@Component
class ResumeHandler {
fun getSectionHandler(section: Section): (ServerRequest) -\> Mono<ServerResponse> =
            { // get section from data and return response }
}
</xmp>


<p>We can iterate through the enum and create a new mapping for each of the sections with the <code>GET</code> function. Furthermore the function <code>getSectionHandler</code> can receive the enum as parameter and use it for handling the response instead of having to rely only on the <code>ServerRequest</code> context.</p>

<p>Now this is only one of the <em>tricks</em> that can be done with functional routing. Having a <a href="https://spring.io/blog/2017/08/01/spring-framework-5-kotlin-apis-the-functional-way#functional-routing-with-the-kotlin-dsl-for-spring-webflux">Kotlin DSL</a> means we can do <strong>any kind of scripting we can think of</strong> when defining the routes. As always:</p>

<p><img class="center" src="/images/posts/2018-05-19/withGreatPower.png" title="‚ÄôWith great power comes great responsibility‚Äô" ></p>

<p>Abusing this feature would make your routing logic a <strong>tangled mess</strong>, too hard to understand and maintain. So be smart about it.</p>

<script src="https://unpkg.com/kotlin-playground@1" data-selector=".kotlin-code"></script>



<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Source: [kotlin-swagger-spring-functional-template][2]<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Parallel Map in Java (From Kotlin)]]></title>
    <link href="http://jivimberg.github.io/blog/2018/05/07/parallel-map-in-java/"/>
    <updated>2018-05-07T13:19:58-07:00</updated>
    <id>http://jivimberg.github.io/blog/2018/05/07/parallel-map-in-java</id>
    <content type="html"><![CDATA[<p>Following up of my <a href="http://jivimberg.io/blog/2018/05/04/parallel-map-in-kotlin/">previous post</a>, I was curious how a parallel map operation would look like using Java‚Äôs <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#parallelStream--"><code>parallelStream</code></a>. Here‚Äôs what I find out.</p>

<!--more-->


<p>In Java to use <code>map</code> you do:</p>

<xmp class="kotlin-code">
import java.util.stream.Collectors

//sampleStart
fun main(args: Array<String>) {
    val output = (1..100).toList()
            .stream()
            .map { it * 2 }
            .collect(Collectors.toList())
    println(output)
}
//sampleEnd
</xmp>


<p><em>(In case you‚Äôre wondering I‚Äôm using Java collections from Kotlin)</em></p>

<p>And to do a <em>parallel</em> <code>map</code> you can simply do:</p>

<xmp class="kotlin-code">
import java.util.stream.Collectors

//sampleStart
fun main(args: Array<String>) {
    val output = (1..100).toList()
            .parallelStream()
            .map { it * 2 }
            .collect(Collectors.toList())
    println(output)
}
//sampleEnd
</xmp>


<p>No need to write a special <code>pmap</code> operation like we did for Kotlin. Just call <code>parallelStream</code> and that‚Äôs it. <em>Pretty cool, right?</em></p>

<p>I was curious about how this solution <strong>compared to the one on <a href="http://jivimberg.io/blog/2018/05/04/parallel-map-in-kotlin/">my previous post</a></strong>,  so I decided to time it too.</p>

<xmp class="kotlin-code">
import java.util.stream.Collectors
import kotlin.system.measureTimeMillis

//sampleStart
fun main(args: Array<String>) {
    val time = measureTimeMillis {
        val output = (1..100).toList()
                .parallelStream()
                .map {
                    Thread.sleep(100)
                    it * 2
                }
                .collect(Collectors.toList())

        println(output)
    }

    println("Total time: $time")
}
//sampleEnd
</xmp>


<p>In this case instead I‚Äôm actually setting a delay of <strong>100 milliseconds</strong> (instead of <em>1,000</em> like I did on my previous post)<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>. I was expecting the total time to be something close to <em>100 milliseconds</em>, just like it was for the Kotlin <code>pmap</code>, <strong>instead I got something close to 5,000</strong>.</p>

<p>Turns out <code>parallelStream</code> uses the default <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html"><em>ForkJoinPool.commonPool</em></a> which by default has a parallelism level <strong>equal to the number of available processors.</strong> In this case 2 processors: <em>100 operations * 100 milliseconds / 2 processors = 5000 milliseconds</em>. You can check the number of available processors simply by adding this line to the script:</p>

<p><code>println(Runtime.getRuntime().availableProcessors())</code></p>

<h2>But, I want more parallelism!</h2>

<p>What if we want to increase the parallelism level? There are <em>2 ways to achieve this.</em></p>

<p><em>The first one</em> is to make our code <strong>run in a custom thread pool</strong> of our choice. Unfortunately Java doesn‚Äôt make it easy to provide a custom thread pool, but <a href="http://www.baeldung.com/java-8-parallel-streams-custom-threadpool">the workaround is not so bad either</a>.</p>

<p><em>The other option</em> is to change the <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html"><em>ForkJoinPool.commonPool</em></a> parallelism level by system property like this:</p>

<p><code>System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", "10")</code></p>

<p>Unfortunately this doesn‚Äôt work on Kotlin Playground so you‚Äôll have to try it on your own machine or take my word that it works.</p>

<p>It‚Äôs worth noting that with the second approach you‚Äôd still be using the same default thread pool <strong>shared globally across the app</strong>. As you can imagine this can be <strong>EXTREMELY BAD</strong> as you‚Äôd be basically depleting resources for the whole application. Some would even argue <a href="https://zeroturnaround.com/rebellabs/java-parallel-streams-are-bad-for-your-health/">this is reason enough not to use <code>parallelStream</code> at all</a>. Although that seems a little extreme if you ask me.</p>

<script src="https://unpkg.com/kotlin-playground@1" data-selector=".kotlin-code"></script>



<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Otherwise the execution takes too long and doesn‚Äôt complete. Probably a limitation of Kotlin Playground<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Parallel Map in Kotlin]]></title>
    <link href="http://jivimberg.github.io/blog/2018/05/04/parallel-map-in-kotlin/"/>
    <updated>2018-05-04T16:32:00-07:00</updated>
    <id>http://jivimberg.github.io/blog/2018/05/04/parallel-map-in-kotlin</id>
    <content type="html"><![CDATA[<p>Ever wonder how to run <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/map.html"><code>map</code></a>  in parallel using coroutines? This is how you do it.</p>

<!--more-->




<xmp class="kotlin-code" data-highlight-only>
import kotlinx.coroutines.experimental.async
import kotlinx.coroutines.experimental.runBlocking

//sampleStart
fun <A, B>Iterable<A>.pmap(f: suspend (A) -> B): List<B> = runBlocking {
    map { async { f(it) } }.map { it.await() }
}
//sampleEnd
</xmp>


<p><em>Confused?</em> Let‚Äôs unpack it.</p>

<p>First we have the <strong>function signature</strong> which is pretty similar to the actual <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/map.html"><code>map</code></a> extension function signature on <code>Iterable</code>. The only thing we added was the <code>suspend</code> keyword on the parameter, which let‚Äôs us use <code>suspend</code> functions in <code>f</code> (as we‚Äôre going to see in a moment).</p>

<p>Then we have the <code>runBlocking</code> which let‚Äôs us bridge the blocking code with the coroutine world. As the name suggests <strong>this will block the current thread until everything inside the block finishes executing</strong>. Which is exactly what we want.</p>

<p>Finally we have the actual execution which is divided in 2 steps. The <em>first step</em> <strong>launches a new coroutine for each function application</strong> using <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/async.html"><code>async</code></a>. This effectively wraps the type of each element with  <code>Deferred</code>. In the <em>second step</em> we wait for all function applications to complete and unwrap the result with <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.experimental/-deferred/await.html"><code>await</code></a>.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>

<h2>How to use it</h2>

<p>Easy! <strong>Just like you use <code>map</code></strong>:</p>

<xmp class="kotlin-code">
import kotlinx.coroutines.experimental.async
import kotlinx.coroutines.experimental.runBlocking

fun <A, B>Iterable<A>.pmap(f: suspend (A) -> B): List<B> = runBlocking {
    map { async { f(it) } }.map { it.await() }
}
//sampleStart
fun main(args: Array<String>) {
    println((1..100).pmap { it * 2 })
}
//sampleEnd
</xmp>


<p>(Psst! I‚Äôm using <a href="https://blog.jetbrains.com/kotlin/2018/04/embedding-kotlin-playground/">Kotlin Playground</a> so you can actually run this code!)</p>

<h2>Prove that it‚Äôs running in parallel</h2>

<p>Ok so let‚Äôs resort to the good old <code>delay</code> to prove that this is actually running in parallel. We are going to add a <strong>delay of 1 second</strong> on each multiplication and measure the time it takes to run.</p>

<p>Running over <em>100 elements</em> the result should be: <strong>close to 1,000 milliseconds if it‚Äôs running in parallel</strong> and close to <em>100,000 milliseconds if it‚Äôs running sequentially</em>.</p>

<xmp class="kotlin-code">
import kotlinx.coroutines.experimental.async
import kotlinx.coroutines.experimental.runBlocking
import kotlin.system.measureTimeMillis
import kotlinx.coroutines.experimental.delay

fun <A, B>Iterable<A>.pmap(f: suspend (A) -> B): List<B> = runBlocking {
    map { async { f(it) } }.map { it.await() }
}
//sampleStart
fun main(args: Array<String>) {
    val time = measureTimeMillis {
        val output = (1..100).pmap {
            delay(1000)
            it * 2
        }

        println(output)
    }

    println("Total time: $time")
}
//sampleEnd
</xmp>




<script src="https://unpkg.com/kotlin-playground@1" data-selector=".kotlin-code"></script>



<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Since I‚Äôm not explicitly passing any  <code>CoroutineContext</code> the <code>DefaultDispatcher</code> will be used. <a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
