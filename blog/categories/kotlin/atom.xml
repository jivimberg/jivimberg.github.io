<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Kotlin | Coding Forest]]></title>
  <link href="http://jivimberg.github.io/blog/categories/kotlin/atom.xml" rel="self"/>
  <link href="http://jivimberg.github.io/"/>
  <updated>2019-03-17T19:35:29-07:00</updated>
  <id>http://jivimberg.github.io/</id>
  <author>
    <name><![CDATA[Juan Ignacio Vimberg]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SQS Consumer Using Kotlin Coroutines]]></title>
    <link href="http://jivimberg.github.io/blog/2019/02/23/sqs-consumer-using-kotlin-coroutines/"/>
    <updated>2019-02-23T16:52:48-03:00</updated>
    <id>http://jivimberg.github.io/blog/2019/02/23/sqs-consumer-using-kotlin-coroutines</id>
    <content type="html"><![CDATA[<p>Today we‚Äôll see how to write a SQS consumer that processes messages in a parallel, non-blocking way, using Kotlin coroutines.</p>

<!--more-->


<h2>The pool of workers pattern</h2>

<p>After some experimentation I‚Äôve opted for using a <em>pool of workers</em> for writing the consumer. For an introduction on the pattern and how to implement it in Kotlin I strongly suggested watching Roman‚Äôs talk from 2018 Kotlin Conf.</p>

<div style="text-align: center;">
    <iframe width="560" height="315" src="https://www.youtube.com/embed/a3agLJQ6vt8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>


<p>For our particular solution we‚Äôll need:</p>

<ol>
<li>One coroutine that periodically retrieves the messages (<strong>MsgReceiver</strong>).</li>
<li>Multiple <strong>workers</strong> that process the receiving messages in parallel without blocking.</li>
<li>A <strong>channel</strong> to communicate between the <em>MsgReceiver</em> coroutine and the <em>Workers</em>.</li>
</ol>


<p><img class="center" src="/images/posts/2019-03-10/consumerDiagram.png" width="800" title="‚ÄòSQS consumer diagram‚Äô" ></p>

<h3><em>fun start()</em></h3>

<p>Let‚Äôs start by creating the elements we mentioned in the previous section. We‚Äôll do this in the <code>start()</code> method.</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
fun start() = launch {
        val messageChannel = Channel<Message>()
        repeat(N_WORKERS) { launchWorker(messageChannel) }
        launchMsgReceiver(messageChannel)
    }
</xmp>


<p>This function launches a coroutine that creates: the channel, <em>N</em> <em>workers</em> and the <em>MsgReceiver</em>.</p>

<p>Don‚Äôt worry too much about how we‚Äôre able to call <code>launch</code> here. I‚Äôll go back to this later.</p>

<h3>Message receiver</h3>

<p>Now it‚Äôs time to write the code for the message receiver:</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
private fun CoroutineScope.launchMsgReceiver(channel: SendChannel<Message>) = launch {
        repeatUntilCancelled {
            val receiveRequest = ReceiveMessageRequest.builder()
                    .queueUrl(SQS_URL)
                    .waitTimeSeconds(20)
                    .maxNumberOfMessages(10)
                    .build()
    
            val messages = sqs.receiveMessage(receiveRequest).await().messages()
            println("${Thread.currentThread().name} Retrieved ${messages.size} messages")
    
            messages.forEach {
                channel.send(it)
            }
        }
    }
</xmp>


<p>This function takes a <code>SendChannel</code> that it‚Äôll use to communicate with the <em>worker</em> coroutines.</p>

<p>It is written as a <code>CoroutineScope</code> to denote that it creates a new coroutine and does not wait for it to complete.</p>

<p>Next thing you‚Äôll notice is that all the code is wrapped with a <code>repeatUntilCancelled</code>. This is a helper function that will repeat our block infinitely, and make sure it keeps running even in the face of exceptions. It will only stop when the coroutine is cancelled. We‚Äôll use this little trick on our <em>Worker</em> code too. Here‚Äôs the code, courtesy of <a href="https://twitter.com/_fletchr">@_fletchr</a>:</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
import kotlinx.coroutines.CancellationException
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.isActive
import kotlinx.coroutines.yield
import java.lang.Thread.currentThread

//sampleStart
suspend fun CoroutineScope.repeatUntilCancelled(block: suspend () -> Unit) {
    while (isActive) {
        try {
            block()
            yield()
        } catch (ex: CancellationException) {
            println("coroutine on ${currentThread().name} cancelled")
        } catch (ex: Exception) {
            println("${currentThread().name} failed with {$ex}. Retrying...")
            ex.printStackTrace()
        }
    }
    
    println("coroutine on ${currentThread().name} exiting")
}
//sampleEnd
</xmp>


<p>We have while loop on the <code>isActive</code> property from the CoroutineScope that will guarantee we keep repeating the block until the coroutine is no longer active (i.e. it has been cancelled). We have access to this property because <code>repeatUntilCancelled</code> is an extension function on CoroutineScope.</p>

<p>Having the <em>try/catch</em> guarantees the coroutine will keep looping even if the block throws an exception (like a connection timeout reading messages from the queue, for example). <code>CancellationException</code> is the exception used by the coroutines machinery to signal the cancellation of the coroutine. We handle it as a special case because we don&rsquo;t want to print a message saying <em>&ldquo;Retrying&hellip;&rdquo;</em>, because the while loop is about to break.</p>

<p>The call to <code>yield()</code> is needed to avoid the case where all threads are busy with CPU intensive coroutines that do not suspend, and thus there&rsquo;s no chance for other coroutines to execute.</p>

<p>Ok, back to our <code>launchMsgReceiver</code> function!  The next part is the actual polling for messages. You‚Äôll notice that I‚Äôm maxing out the <code>waitTimeSeconds</code>  so the call waits up to <em>20 seconds</em>, for at least one message to be available before returning empty. I‚Äôm also picking the biggest value for the number of messages being retrieved at once (10), because the whole point of my consumer is to be able to process as many of them in parallel, as possible.</p>

<p>Next line is the <code>receiveMessage</code> call on the SQS client. One extremely important detail is that <strong>I‚Äôm using the <code>SqsAsyncClient</code> from <a href="https://github.com/aws/aws-sdk-java-v2">AWS Java SDK v2</a></strong>. Why? Because I don‚Äôt want my thread to be blocked waiting for messages to appear. And the <code>SqsAsyncClient</code> of Java SKD v1 returns only a <code>Future</code> (because it needs to be compatible with Java 1.6) making it harder to integrate with the coroutines world. Instead, the new version returns <code>CompletableFuture</code>, which lets us call <code>await()</code> (from <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-jdk8/">Kotlinx Coroutines JDK8</a>) to suspend our coroutine until the result is ready <strong>without blocking the thread</strong>.</p>

<p>Finally we iterate over the messages and send them through the channel using  <code>channel.send(it)</code> . Because of the way <a href="https://kotlinlang.org/docs/reference/coroutines/channels.html">unbuffered channels</a> work the <code>send</code> call will suspend if there is no worker available to receive the message. This is a very nice property because it means <strong>we get <a href="https://medium.com/@jayphelps/backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7"><em>backpressure</em></a> for free</strong>. If at some point our workers are not able to process the messages fast enough, the <em>MsgReceiver</em> will just wait (suspend) until some worker becomes available, instead of fetching even more messages, drowning the workers.</p>

<h3>Worker</h3>

<p>Now let‚Äôs take a look at the worker that will process the messages:</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
 private fun CoroutineScope.launchWorker(channel: ReceiveChannel<Message>) = launch {
        repeatUntilCancelled {
            for (msg in channel) {
                try {
                    processMsg(msg)
                    deleteMessage(msg)
                } catch (ex: Exception) {
                    println("${Thread.currentThread().name} exception trying to process message ${msg.body()}")
                    ex.printStackTrace()
                    changeVisibility(msg)
                }
            }
        }
    }
</xmp>


<p>The first lines are pretty similar to the <em>MsgReceiver</em>. We‚Äôre again launching a coroutine and not waiting for it to complete, and thus we have the <code>launch</code> call and our function is an extension of <code>CoroutineScope</code>. We‚Äôre also wrapping everything in a <code>repeatUntilCancelled</code> for the same reasons we used it before. The only difference you might notice is that it takes a <code>ReceiveChannel</code> instead of <code>SendChannel</code>, because this is the receiving end of the communication.</p>

<p>Next we use a <code>for</code> loop to consume messages from the channel. It will suspend the coroutine if there are no new messages in the channel. The use of <code>for</code> is important because we‚Äôre doing <a href="https://kotlinlang.org/docs/reference/coroutines/channels.html#fan-out">fan-out</a>, we have multiple coroutines consuming from the same channel. Consuming with <code>for</code> guarantees us that if one coroutine fails it won‚Äôt cancel the underlying channel, which is what would happen if we had used <code>consumeEach</code> to go through the messages, instead.</p>

<p>Also channels have the nice property of <a href="https://kotlinlang.org/docs/reference/coroutines/channels.html#channels-are-fair">being fair</a>. Meaning that the first coroutine that invoke <code>receive</code> gets the message. FIFO style.</p>

<p>If something fails while processing the message we (try to) <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-visibility-timeout.html">change the visibility timeout</a> so that the message will show up in the queue again sooner, and picked up for re-processing.</p>

<p>Let‚Äôs now take a look at <em>processMessage(msg)</em> implementation:</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
private suspend fun processMsg(message: Message) {
        println("${Thread.currentThread().name} Started processing message: ${message.body()}")
        delay((1000L..2000L).random())
        println("${Thread.currentThread().name} Finished processing of message: ${message.body()}")
    }
</xmp>


<p>As you can tell, this is a mock implementation. There‚Äôs nothing interesting happening here. We just <code>delay</code> for a few seconds and then continue saying that message has been processed. This is where you‚Äôd put your actual logic. Or better yet, if you plan to reuse your SQS consumer implementation <strong>you might want to turn this into a Lambda expression that can be passed as a parameter</strong>.</p>

<p>Finally let‚Äôs see <em>deleteMsg(msg)</em> and <em>changeVisibility(msg)</em>:</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
private suspend fun deleteMessage(message: Message) {
        sqs.deleteMessage { req ->
            req.queueUrl(SQS_URL)
            req.receiptHandle(message.receiptHandle())
        }.await()
        println("${Thread.currentThread().name} Message deleted: ${message.body()}")
    }
    
    private suspend fun changeVisibility(message: Message) {
        sqs.changeMessageVisibility { req ->
            req.queueUrl(SQS_URL)
            req.receiptHandle(message.receiptHandle())
            req.visibilityTimeout(10)
        }.await()
        println("${Thread.currentThread().name} Changed visibility of message: ${message.body()}")
    }
</xmp>


<p>This 2 methods follow the same pattern: call the <code>SQSAsyncClient</code> corresponding method then <code>await()</code>, finally log.</p>

<h3>Contexts, dispatchers and supervisors</h3>

<p>Now that we have a good grasp on the different parts of our solution, let‚Äôs pay closer attention to how the coroutines are created and dispatched.</p>

<p>One of the central tenets of Kotlin coroutines is <em><a href="https://kotlinlang.org/docs/reference/coroutines/basics.html#structured-concurrency">structured concurrency</a></em>. <em>Structured concurrency</em> helps us write code that properly cleans up active coroutines in case of exceptions. If you think you‚Äôre a hardcore developer and instead launch your coroutines using <code>GlobalScope.launch { ... }</code>, then you risk leaking coroutines when something fails (check <a href="https://twitter.com/relizarov">@relizarov</a>‚Äôs <a href="https://medium.com/@elizarov/structured-concurrency-722d765aa952">article</a> to see an example of this). So, how‚Äôs are our coroutines structured?</p>

<p><img class="center" src="/images/posts/2019-03-10/coroutinesScope.png" width="400" title="‚Äòcoroutines structure‚Äô" ></p>

<p>To mark the lifecycle of our coroutines we extend our class with <code>CoroutineScope</code> and provide a context by overriding <code>corroutinesContext: CorroutineContext</code>. This is the context that‚Äôll be used by our root coroutine, the one started by the <code>launch</code> call on the <code>start()</code> function, at the beginning of this post. Since we want our coroutines to match the lifecycle of our class we‚Äôve added a <code>close()</code> method that clients can call to cancel all the coroutines in the consumer. If you‚Äôre using some kind of framework you might want to tie this function the lifecycle of the class in some other way.</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
package com.jivimberg.sqs

import kotlinx.coroutines.\*
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.channels.ReceiveChannel
import kotlinx.coroutines.channels.SendChannel
import kotlinx.coroutines.future.await
import software.amazon.awssdk.regions.Region
import software.amazon.awssdk.services.sqs.SqsAsyncClient
import software.amazon.awssdk.services.sqs.model.Message
import software.amazon.awssdk.services.sqs.model.ReceiveMessageRequest
import kotlin.coroutines.CoroutineContext

//sampleStart

class SqsSampleConsumerChannels(
        private val sqs: SqsAsyncClient
) : CoroutineScope {

    private val supervisorJob = SupervisorJob()
    override val coroutineContext: CoroutineContext
        get() = Dispatchers.IO + supervisorJob
    
    fun start() = launch {
        val messageChannel = Channel<Message>()
        repeat(N_WORKERS) { launchWorker(messageChannel) }
        launchMsgReceiver(messageChannel)
    }
    
    fun stop() {
        supervisorJob.cancel()
    }

//sampleEnd

    private fun CoroutineScope.launchMsgReceiver(channel: SendChannel<Message>) = launch {
        repeatUntilCancelled {
            val receiveRequest = ReceiveMessageRequest.builder()
                    .queueUrl(SQS_URL)
                    .waitTimeSeconds(20)
                    .maxNumberOfMessages(10)
                    .build()
    
            val messages = sqs.receiveMessage(receiveRequest).await().messages()
            println("${Thread.currentThread().name} Retrieved ${messages.size} messages")
    
            messages.forEach {
                channel.send(it)
            }
        }
    }
    
    private fun CoroutineScope.launchWorker(channel: ReceiveChannel<Message>) = launch {
        repeatUntilCancelled {
            for (msg in channel) {
                try {
                    processMsg(msg)
                    deleteMessage(msg)
                } catch (ex: Exception) {
                    println("${Thread.currentThread().name} exception trying to process message ${msg.body()}")
                    ex.printStackTrace()
                    changeVisibility(msg)
                }
            }
        }
    }
    
    private suspend fun processMsg(message: Message) {
        println("${Thread.currentThread().name} Started processing message: ${message.body()}")
        delay((1000L..2000L).random())
        println("${Thread.currentThread().name} Finished processing of message: ${message.body()}")
    }
    
    private suspend fun deleteMessage(message: Message) {
        sqs.deleteMessage { req ->
            req.queueUrl(SQS_URL)
            req.receiptHandle(message.receiptHandle())
        }.await()
        println("${Thread.currentThread().name} Message deleted: ${message.body()}")
    }
    
    private suspend fun changeVisibility(message: Message) {
        sqs.changeMessageVisibility { req ->
            req.queueUrl(SQS_URL)
            req.receiptHandle(message.receiptHandle())
            req.visibilityTimeout(10)
        }.await()
        println("${Thread.currentThread().name} Changed visibility of message: ${message.body()}")
    }
}

fun main() = runBlocking {
    println("${Thread.currentThread().name} Starting program")
    val sqs = SqsAsyncClient.builder()
            .region(Region.US_EAST_1)
            .build()
    val consumer = SqsSampleConsumerChannels(sqs)
    consumer.start()
    delay(30000)
    consumer.stop()
}

private const val N\_WORKERS = 4
</xmp>


<p>Our <code>coroutineContext</code> has 2 elements: the <code>Dispatcher</code> and the <code>supervisorJob</code> (<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines.experimental/-coroutine-context/plus.html">the <code>+</code> operation</a> concatenates both elements in a new <code>CoroutineContext</code> ).</p>

<p>The <em>Dispatcher</em> marks which thread our coroutine will run on. In our case I used <code>Dispatchers.IO</code> that uses a shared pool of threads for doing IO (more details <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-i-o.html">here</a>). This is because most of the time my coroutines are doing IO operations for: receiving messages, deleting them, changing visibility, etc. If, in your case, processing a message requires a CPU intensive calculation you‚Äôd use <code>Dispatchers.Default</code> through the <code>withContext</code> function like this:</p>

<xmp class="kotlin-code" data-highlight-only theme="darcula">
private suspend fun processMsg(message: Message) = withContext(Dispatchers.Default) {
        // Your code here
    }
</xmp>


<h2>In case of exception</h2>

<p>Because we‚Äôre responsible developers, let‚Äôs see what would happen if something were to fail.</p>

<p>As a first line of defense we know both our <em>Workers</em> and the <em>MsgReceiver</em> are running in <code>repeatUntilCancelled</code> loops, so any exception should be logged and ignored. This is ok for us because once the visibility timeout is over, the message will re-appear in the queue for another worker to consume. Still, to be extra careful, let‚Äôs consider what would happen with our coroutines in case of exception if we didn‚Äôt have <code>repeatUntilCancelled</code>s.</p>

<p>The whole premise of <a href="https://kotlinlang.org/docs/reference/coroutines/basics.html#structured-concurrency">structured concurrency</a> is to avoid leaking coroutines in case of failure. That‚Äôs why, by default, <strong>whenever a child coroutine terminates with exception its parent and siblings are cancelled too</strong>. This is a nice property, but not quite what we want in this case. We don‚Äôt want all workers to be cancelled because one worker threw an exception. That‚Äôs why we use <code>supervisorJob</code> as part of our <code>coroutineContext</code>. <a href="https://kotlinlang.org/docs/reference/coroutines/exception-handling.html#supervision-job">SupervisorJob</a> is like a regular job, with the exception that cancellation is propagated only downwards.</p>

<p><img class="center" src="/images/posts/2019-03-10/Supervisor.png" width="600" title="‚ÄòRegular Job vs. Supervisor Job‚Äô" ></p>

<p>Finally, don‚Äôt forget to configure a <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html">dead letter queue</a> for those messages that can‚Äôt be processed even after multiple retries.</p>

<hr />

<p>That‚Äôs all! You can find all the code from this post in <a href="https://gist.github.com/jivimberg/b0f4f94871c6f3e7d17fae1106c28047">this gist</a>. If you have any improvement to suggest, I‚Äôd ‚ù§Ô∏è to hear about it. Leave me a comment down there.</p>

<p><img class="right-fill" src="/images/signatures/signature11.png" width="200" title="‚ÄòMy signature‚Äô" ></p>

<script src="https://unpkg.com/kotlin-playground@1" data-selector=".kotlin-code"></script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using UUID on Spring Data JPA Entities]]></title>
    <link href="http://jivimberg.github.io/blog/2018/11/05/using-uuid-on-spring-data-jpa-entities/"/>
    <updated>2018-11-05T07:25:37-08:00</updated>
    <id>http://jivimberg.github.io/blog/2018/11/05/using-uuid-on-spring-data-jpa-entities</id>
    <content type="html"><![CDATA[<p>In this article I‚Äôll explore <strong>how to model a <a href="https://stackoverflow.com/questions/6033905/create-the-perfect-jpa-entity">JPA Entity</a> using an <a href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUID</a></strong> as Primary Key working with <a href="https://spring.io/projects/spring-data-jpa">Spring Data JPA.</a></p>

<!--more-->


<p><img class="center" src="/images/posts/2018-11-07/uuid.png" title="‚Äòuuid key‚Äô" ></p>

<h1>Why UUIDs?</h1>

<p>Usually we use numerical keys on our models and let the DB generate that for us on persistence. But there are <strong>some reasons why you might prefer to use UUIDs</strong> as your Primary Key instead. Namely:</p>

<ul>
<li><strong>UUIDs are globally unique.</strong> This means that we don‚Äôt need a centralized component to generate unique ids, <strong>we can generate the ids on the application itself</strong> instead of relying on <a href="https://vladmihalcea.com/hibernate-and-uuid-identifiers/">some UUID generator</a> that populates the <code>id</code> field on persist.</li>
<li>Having globally unique ids also means that <strong>your ids are unique across databases.</strong> This allows us to move data across databases without having to check for conflicting ids.</li>
<li>Having application generated ids means the id is known even before the entity is persisted. This lets us <strong>model our entities as <a href="https://proandroiddev.com/kotlin-for-beginners-immutability-and-the-value-of-val-78ab45b60b57">immutable objects</a></strong> and we avoid having to handle null values on the id.</li>
</ul>


<p>But as you probably already know: <a href="https://en.wikipedia.org/wiki/There_ain%27t_no_such_thing_as_a_free_lunch">üö´üÜìüçΩ</a>. So here are some of the downsides of using UUIDss for you to consider:</p>

<ul>
<li><strong>Storage space.</strong> As you can imagine storing an UUID takes a lot more space than storying an Int. Specially if you make the mistake of storing it as a <code>String</code>. You might think Id space is not a big deal, but consider that <strong>Primary Keys are often used in indexes and as Foreign Keys on other tables</strong>. So the numbers start to add up.</li>
<li>They are <strong>not human friendly</strong>. What‚Äôs easier to remember: <code>223492</code> or <code>453bd9d7-83c0-47fb-b42e-0ab045b29f83¬†</code>? This is specially true if you happen to be exposing your ids on your public APIs. Think: <code>/albums/2311445/photo/7426321</code> vs <code>/albums/b3480d79-e458-4675-a7ba-61ac5957cb7c/photo/19b24967-1741-4405-a746-d2b081ee45f2¬†</code>.</li>
</ul>


<p><strong>If you‚Äôre still on the fence</strong> here‚Äôs a great article talking about the pros and cons of using UUIDs as primary keys: <a href="https://tomharrisonjr.com/uuid-or-guid-as-primary-keys-be-careful-7b2aa3dcb439">https://tomharrisonjr.com/uuid-or-guid-as-primary-keys-be-careful-7b2aa3dcb439</a>.</p>

<h1>How to do it</h1>

<p>Now let‚Äôs talk about how we can implement this. I‚Äôll go step by step explaining why we add each piece of code.</p>

<p>The first thing we need to do is <strong>generate the UUID</strong>. As mentioned above we‚Äôd like to do this on the application code so we can have <em>immutable entities</em>. Generating the UUID is easy, all we need to do is: <code>UUID.randomUUID()</code>. So our entity would look like this:</p>

<xmp class="kotlin-code" theme="darcula" data-highlight-only>
import java.util.*
import javax.persistence.Id
import javax.persistence.Entity

//sampleStart
@Entity
class Artist(
        @Id val id: UUID = UUID.randomUUID(),
        val name: String
)
//sampleEnd
</xmp>


<p>You‚Äôve probably noticed how we‚Äôre making the id an argument of the <a href="https://kotlinlang.org/docs/reference/classes.html#constructors">primary constructor</a>. This is required to <strong>let clients construct entities with known ids to represent persisted objects</strong>. This is useful for example to <strong>model an update operation</strong>: create an enwtity with a known id and updated values, then call <code>save()</code> on such entity.</p>

<h2>isNew?</h2>

<p>As mentioned we‚Äôre using <a href="https://spring.io/projects/spring-data-jpa">Spring Data JPA</a> for our Repository layer. Now there‚Äôs a small detail we have to take into account when <strong>using application provided ids with Spring Data</strong>. If you do a <code>artistRepository.save(Artist(name = "David Bowie"))</code> you might get an output like this:</p>

<p><img class="center" src="/images/posts/2018-11-07/2sql.png" title="‚Äòpersist logs‚Äô" ></p>

<p>If you pay close attention to the log you‚Äôll notice that <strong>Hibernate is actually executing 2 SQL queries</strong>: one <code>select</code> followed by one <code>insert</code>. Not quite what we were expecting.</p>

<p>The reason for this behavior is the implementation of Spring Data‚Äôs <a href="https://github.com/spring-projects/spring-data-jpa/blob/master/src/main/java/org/springframework/data/jpa/repository/support/SimpleJpaRepository.java"><code>SimpleJpaRepository.java</code></a>. In particular the <a href="https://github.com/spring-projects/spring-data-jpa/blob/01e36dbb44d6bc87f7deb3b6d6dacc955ea6c8bd/src/main/java/org/springframework/data/jpa/repository/support/SimpleJpaRepository.java#L506"><code>save()</code></a> method:</p>

<pre><code class="java">@Transactional
public &lt;S extends T&gt; S save(S entity) {
    if (entityInformation.isNew(entity)) {
        em.persist(entity);
        return entity;
    } else {
        return em.merge(entity);
    }
}
</code></pre>

<p><strong>The double SQL statement is caused by the call to <code>merge()</code></strong>. By default the way this class decides whether to do a <code>persist()</code> or a <code>merge()</code> <strong>is simply by checking if the id is null</strong>. Which works fine for DB assigned ids, but <em>not</em> for application assigned ones. üòï</p>

<p><strong>The best way to control this is by implementing the <a href="https://github.com/spring-projects/spring-data-commons/blob/master/src/main/java/org/springframework/data/domain/Persistable.java"><code>Persistable&lt;ID&gt;</code></a> interface</strong> providing a <code>isNew()</code> method. Since this is something we‚Äôll want to do every time we use application generated UUIDs <strong>I‚Äôll extract this into an abstract class</strong> and making use of the <code>@MappedSuperClass</code> annotation.</p>

<xmp class="kotlin-code" theme="darcula" data-highlight-only>
import org.springframework.data.domain.Persistable
import java.util.*
import javax.persistence.*

//sampleStart
@MappedSuperclass
abstract class AbstractBaseEntity(givenId: UUID? = null) : Persistable<UUID> {

    @Id
    @Column(name = "id", length = 16, unique = true, nullable = false)
    private val id: UUID = givenId ?: UUID.randomUUID()

    @Transient
    private var persisted: Boolean = givenId != null
    
    override fun getId(): UUID = id

    override fun isNew(): Boolean = !persisted

    override fun hashCode(): Int = id.hashCode()

    override fun equals(other: Any?): Boolean {
        return when {
            this === other -> true
            other == null -> false
            other !is AbstractBaseEntity -> false
            else -> getId() == other.getId()
        }
    }

    @PostPersist
    @PostLoad
    private fun setPersisted() {
        persisted = true
    }
}
//sampleEnd

</xmp>


<blockquote><p>This design was <strong>suggested to me by <a href="https://twitter.com/PabloHernanS">@paschmid</a> and <a href="https://twitter.com/rcruzjo">@rcruzjo</a></strong>, this code would be quite ugly if it weren‚Äôt for them!</p></blockquote>

<p>You can see how the <code>persisted</code> state is decided based on whether an id is provided on creation or not, to account for updates. Also notice how <strong>its value gets automatically updated upon <em>persist</em> and <em>load</em></strong> thanks to <code>@PostPersist</code> and <code>@PostLoad</code> annotations.</p>

<p>Also since <code>id</code> is now <em>unique</em> and <em>non-nullable</em> <strong>we can use it to implement <code>equals()</code> and <code>hashcode()</code></strong> and avoid falling in some of the common pitfalls of implementing this methods (to learn more about this check <a href="https://vladmihalcea.com/how-to-implement-equals-and-hashcode-using-the-jpa-entity-identifier/">this article</a> by <a href="https://twitter.com/vlad_mihalcea">@vlad_mihalcea</a> and <a href="https://kotlinexpertise.com/hibernate-with-kotlin-spring-boot/">this one</a> by <a href="https://twitter.com/s1m0nw1">@s1m0nw1</a>).</p>

<p>And in case you‚Äôre wondering <strong>why we need an explicit <code>getId()</code> function</strong>, it is because of this issue: <a href="https://youtrack.jetbrains.com/issue/KT-6653">Kotlin properties do not override Java-style getters and setters</a>.</p>

<h1>Putting it all together</h1>

<p>Finally let‚Äôs see how a concrete entity would use this.</p>

<xmp class="kotlin-code" theme="darcula" data-highlight-only>
import org.springframework.data.repository.CrudRepository
import java.util.*
import javax.persistence.Entity

//sampleStart
@Entity
class Artist(
        id: UUID? = null,
        val name: String
) : AssignedIdBaseEntity(id)
//sampleEnd
</xmp>


<p>Pretty similar to our original approach right? Thanks to the abstract class all the <code>isNew()</code> <strong>implementation details are hidden</strong> from concrete entities.</p>

<p>And now if we do a <code>save()</code> on a new entity <strong>we get one single SQL statement</strong> as we were expecting.</p>

<p><img class="center" src="/images/posts/2018-11-07/1sql.png" width="600" title="‚Äòpersist logs with abstractEntity‚Äô" ></p>

<hr />

<p>You can find all the <strong>code samples</strong> for this post on <strong><a href="https://github.com/jivimberg/spring-data-uuid-example">this GitHub repo</a></strong>.</p>

<script src="https://unpkg.com/kotlin-playground@1" data-selector=".kotlin-code"></script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reactive GraphQL Subscriptions From Kafka]]></title>
    <link href="http://jivimberg.github.io/blog/2018/10/23/reactive-graphql-subscriptions-from-kafka/"/>
    <updated>2018-10-23T07:58:14-07:00</updated>
    <id>http://jivimberg.github.io/blog/2018/10/23/reactive-graphql-subscriptions-from-kafka</id>
    <content type="html"><![CDATA[<p>In this post I‚Äôll be exploring how to implement <a href="https://github.com/facebook/graphql/blob/master/rfcs/Subscriptions.md">GraphQL subscriptions</a> <em>reactively</em> on a Spring Boot application using <a href="https://kafka.apache.org/">Kafka</a>.</p>

<!--more-->


<h1>The use case</h1>

<p>So, <em>what are we trying to achieve?</em> We want to provide <strong>a way for clients to get notified</strong> whenever an event occurs in the application.</p>

<p>The GraphQL way of doing this is through a <a href="https://github.com/facebook/graphql/blob/master/rfcs/Subscriptions.md">Subscription</a>. For the application events we‚Äôre using Kafka. So all we are trying to do is to tie those 2 things so that <strong>whenever an event pops up in Kafka all clients with an active subscription get notified</strong>.</p>

<p><img class="center" src="/images/posts/2018-10-24/SubscriptionFlow.png" width="700" title="‚ÄòSubscription flow diagram‚Äô" ></p>

<h1>The setup</h1>

<p>Let‚Äôs introduce the different pieces of the puzzle:</p>

<ol>
<li>I have a <a href="https://spring.io/guides/gs/spring-boot/">Spring Boot application</a> that has some business logic.</li>
<li>Using <a href="https://github.com/graphql-java-kickstart/graphql-spring-boot"><code>graphql-spring-boot-starter</code></a> I‚Äôm exposing my service through a GraphQL API. <strong>One of those endpoints it‚Äôs going to be a Subscription endpoint.</strong> It‚Äôs schema definition looks something like this:</li>
</ol>


<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">type</span> <span class="n">Subscription</span> <span class="o">{</span>
</span><span class='line'> <span class="nl">event:</span> <span class="n">EventMessage</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<ol>
<li>On the other end I have a <a href="https://kafka.apache.org/documentation/#intro_topics">Kafka topic</a> with events that a user might be interested in. We plan to use <a href="https://github.com/reactor/reactor-kafka">Reactor Kafka</a> to <strong>consume the events through a reactive stream</strong>.</li>
</ol>


<p><img class="center" src="/images/posts/2018-10-24/Setup.png" width="800" title="‚ÄôSetup diagram‚Äô" ></p>

<p>So the challenge is: <em>how do we connect all this pieces together?</em></p>

<h1>Reactive all the way</h1>

<p>To implement the resolver <a href="https://github.com/graphql-java-kickstart/graphql-java-tools">GraphQL Java Tools</a> <strong>requires that we implement a function that returns a <code>Publisher&lt;T&gt;</code></strong>. Where <em>T</em> is the type of event to be pushed to the subscriber. From <a href="https://github.com/graphql-java/graphql-java">GraphQL Java</a> documentation:</p>

<blockquote><p>What is special is that the initial result of a subscription query is a <strong>reactive-streams¬†Publisher¬†object</strong> which you need to use to get the future values.</p></blockquote>

<p>On the other end <strong>we can use <a href="https://github.com/reactor/reactor-kafka">Reactor Kafka</a> to create a reactive Receiver</strong> to consume the events from the topic. Then all that‚Äôs left is <strong>obtaining a <code>Publisher</code> from this receiver so that clients can subscribe to it</strong>. This is all the code we need:</p>

<xmp class="kotlin-code" theme="darcula" data-highlight-only>
import graphql.schema.DataFetchingEnvironment
import org.reactivestreams.Publisher
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Component
import reactor.core.publisher.Flux
import reactor.kafka.receiver.KafkaReceiver
import reactor.kafka.receiver.ReceiverOptions

@Component
class SubscriptionsResolverImpl(
    receiverOptions: ReceiverOptions<String, EntityUpdated>                 // Receiver configuration. Injected by Spring
) : SubscriptionsResolver {

    private val logger = LoggerFactory.getLogger(javaClass)

    private val kafkaReceiver: Flux<GraphqlEvents.Update> by lazy {         // Use lazy to delay KafkaReceiver initialization
        KafkaReceiver.create(receiverOptions).receive()                     // Create Kafka reactive receiver
            .map { GraphqlEvents.Update.fromEvent(it.value()) }             // Map from Kafka event to Graphql Event
            .doFinally { logger.info("Closing with signal: ${it.name}") }   // Log message on stream closure
            .publish()                                                      // Get a ConnectableFlux. Turns stream to hot
            .autoConnect()                                                  // Connect to upstream on first subscription
    }

    override fun event(env: DataFetchingEnvironment): Publisher<GraphqlEvents.Update> {
        logger.info("GraphQL 'event' subscription called")                  // Log message on each new subscription
        return kafkaReceiver                                                // Returns kafkaReceiver for GraphQL to subscribe to it
    }
}
</xmp>


<p>Just to recap. We are <strong>creating a Kafka Receiver</strong> for the topic we care about (the topic configuration is part of the <code>receiverOptions</code> object, not shown in the snippet).</p>

<p>We are <strong>mapping the event</strong> from the <em>Kafka model</em> to the <em>GraphQL model</em> through the <code>map()</code> method.</p>

<p>Then we are turning the receiver into a hot stream by calling <code>publish()</code>. We are doing this because <strong>we want new subscribers to only see events that happened after they subscribed to the <code>Publisher</code></strong>. And that‚Äôs exactly what <code>publish()</code> does. In fact if you pay close attention to the marble diagram of the <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#publish--">method documentation</a> you‚Äôll notice how <strong>it looks pretty similar to our use case flow diagram.</strong></p>

<p><img class="center" src="/images/posts/2018-10-24/publish.png" width="500" title="‚ÄòPublish marble diagram‚Äô" ></p>

<p>We‚Äôre calling <code>autoConnect()</code> so that it connects to the upstream source as soon as the first <code>Subscriber</code> subscribes.</p>

<p>Finally we‚Äôre implementing the <code>event</code> function <strong>by simply returning the reference to our hot stream of events</strong>. Whenever a new client calls the Subscription endpoint <strong>GraphQL Java will subscribe to this stream</strong> and send a message for every new event that shows up in the configured Kafka topic.</p>

<script src="https://unpkg.com/kotlin-playground@1" data-selector=".kotlin-code"></script>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Random Thoughts on Using Gradle With Kotlin DSL]]></title>
    <link href="http://jivimberg.github.io/blog/2018/08/28/random-thoughts-on-gradle-and-kotlin-dsl/"/>
    <updated>2018-08-28T08:36:57-07:00</updated>
    <id>http://jivimberg.github.io/blog/2018/08/28/random-thoughts-on-gradle-and-kotlin-dsl</id>
    <content type="html"><![CDATA[<p>Since Gradle 3.0 you can <a href="https://blog.gradle.org/kotlin-meets-gradle"><strong>write your build scripts using Kotlin instead of Groovy</strong></a>. I was curious, so I decided to give it a try. Here are my thoughts on the process.</p>

<!--more-->


<h1>Why?</h1>

<p>Ok, we can write our build scripts in Kotlin, but you might be wondering: <em>‚Äùwhy would I want to do that?‚Äù</em> Here are my reasons:</p>

<h2>1. All things Kotlin</h2>

<p>Our backend codebase is <em>mostly written in Kotlin</em>. We even wrote our <a href="https://jivimberg.io/blog/2018/07/03/writing-githooks-in-kotlin/">githooks using Kotlin scripts!</a> So it was only natural to use Kotlin on our build tools too.</p>

<p>Being able to use the same language across the stack means that your learning efforts pays double. This way <strong>the team doesn‚Äôt have to learn a new language just to write a simple Gradle task.</strong> And as an added bonus you can apply <em>the same testing, coverage and code inspection tools</em> that you use in production to your tooling code.</p>

<h2>2. IDE support</h2>

<p>The second reason for making the transition was IDE support. Groovy is a dynamically typed language, which makes it harder for the IDE to provide accurate code completion and script validity through type checks. Kotlin being statically typed doesn‚Äôt suffer from the same problems</p>

<p><img class="center" src="/images/posts/2018-09-11/kotlin-code-completion.png" title="‚ÄòKotlin code completion‚Äô" ></p>

<h2>3. Interoperability</h2>

<p>As you probably know <a href="https://kotlinlang.org/docs/reference/java-interop.html">Kotlin was designed with Java interoperability in mind</a>. And the same interoperability <a href="">extends to Groovy code</a>.</p>

<p>This interoperability let us <strong><a href="https://guides.gradle.org/migrating-build-logic-from-groovy-to-kotlin/#calling_kotlin_from_groovy_2">call Groovy code from Kotlin</a> and <a href="https://guides.gradle.org/migrating-build-logic-from-groovy-to-kotlin/#calling_kotlin_from_groovy">viceversa</a></strong>. Which effectively means that you can have <strong>a mix of both Groovy and Kotlin scripts working together in the same project</strong>. So no need to migrate all your build scripts at once, or to push stubborn <em>‚ÄúWally‚Äù</em> to learn Kotlin DSL.</p>

<p><img class="center" src="/images/posts/2018-09-11/wally2.png" title="‚ÄòWally‚Äô" ></p>

<h1>The exodus</h1>

<p><em>‚ÄùSo how painful was the migration?‚Äù</em> It wasn‚Äôt that bad really. Kotlin DSL was designed to be pretty similar to the classic <code>build.gradle</code> files.</p>

<p>You‚Äôll just have to <strong>push through that first moment</strong> when nothing seems to be working, your project doesn‚Äôt compile at all, and you know you‚Äôre a <code>‚åò + Z</code> away from a pristine working copy. <em>But you can&rsquo;t make an omelet without breaking a few eggs, can you?</em></p>

<p><img class="center" src="/images/posts/2018-09-11/panic.png" title="‚ÄòPanic!‚Äô" ></p>

<p><strong>I just wish there was some kind of automatic migration action in IntelliJ.</strong> Even if it‚Äôs a best effort that leaves you half way there, I‚Äôd greatly appreciate it. Ideally it should work just like when you paste some Java code into a Kotlin file: <code>‚åò + V</code> + ‚ú®<em>fairy dust</em>‚ú® and you have your <code>build.gradle.kts</code> ready to go.</p>

<h3>Resources</h3>

<p>This are the resources that help me complete the migration. Hopefully you‚Äôll find them helpful too.</p>

<ul>
<li><a href="https://guides.gradle.org/migrating-build-logic-from-groovy-to-kotlin/"><strong>Official Gradle migration guide</strong></a> <strong>Start here!</strong> You don‚Äôt have to cover the whole thing but you can skim through it and later go back to the section you need.</li>
<li><a href="https://github.com/gradle/kotlin-dsl/tree/master/samples/"><strong>Samples in the Kotlin DSL repo</strong></a> This is <strong>the go-to place for Kotlin DSL samples</strong>. You‚Äôll find yourself coming back to this repo over and over. Be sure to search the <em>Issues</em> section too.</li>
<li>For the times when the <a href="https://github.com/gradle/kotlin-dsl/tree/master/samples/">Kotlin DSL repo</a> doesn‚Äôt have what you‚Äôre looking for, I find it useful to use <a href="https://github.com/search/advanced"><strong>Github Search</strong></a> looking for code in files with <code>*.kts</code> extension.</li>
<li><a href="https://github.com/jnizet/gradle-kotlin-dsl-migration-guide"><strong>jnizet/gradle-kotlin-dsl-migration-guide</strong></a> this is another migration guide that has proven useful in the past.</li>
<li>Finally I followed <a href="https://handstandsam.com/2018/02/11/kotlin-buildsrc-for-better-gradle-dependency-management/"><strong>this article</strong></a> by <a href="https://handstandsam.com/about-me/">Handstand Sam</a> to do <em>dependency management</em> on out multi-module project.</li>
</ul>


<h1>The not so good</h1>

<h2>1. <em>‚ÄúI can‚Äôt just copy-past things from Stack Overflow‚Äù</em></h2>

<p><img class="center" src="/images/posts/2018-09-11/copy-paste.jpg" width="250" title="‚ÄòCopy paste from Stack Overflow‚Äô" ></p>

<p>This is <strong>by far the biggest drawback</strong>. In my experience most teams have one or two <em>‚Äùbuild tool experts‚Äù</em>. The rest of the team just use a few tasks and maybe add a dependency every now and then. This casual user might have a harder time using Kotlin DSL because <strong>copy-pasting pieces of code from the web will not work out of the box</strong>. Converting this snippets to Kotlin DSL is not rocket-science, but in some cases it might require some basic level of understanding of how Kotlin DSL works.</p>

<p>This is specially true when using plugins that were not designed with Kotlin DSL in mind (I‚Äôm looking at you <a href="https://github.com/google/protobuf-gradle-plugin/issues/219">protobuf Gradle plugin</a>).</p>

<h2>2. IDE support could be better</h2>

<p>Remember all the nice things I said about IDE auto-completion on the build scripts? Well let me clarify: <em>‚ÄúIDE support is awesome‚Ä¶ most of the time‚Äù</em>.</p>

<p>Once you have your script fully migrated and IntelliJ has finished indexing then everything should work just fine. But to get there you‚Äôll have to have your full <code>build.gradle</code> script fully migrated. That‚Äôs why my advice is to <strong>comment everything out and start migrating piece by piece</strong>. For example you can start with configuring the <em>repositories</em>, and <em>plugins</em> and only then move to <em>dependencies</em>.</p>

<p>This gets intensified if you are working on a <a href="https://guides.gradle.org/creating-multi-project-builds/">multi-module project</a> and/or you‚Äôre using <a href="https://docs.gradle.org/current/userguide/custom_plugins.html"><code>buildSrc</code> for custom plugins</a>.</p>

<p>The silver lining is that IDE support is getting better with each release, and once you‚Äôve migrated everything it mostly works.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JaCoCo &amp; Kotlin: Coverage on Generated Code]]></title>
    <link href="http://jivimberg.github.io/blog/2018/08/12/jacoco-and-kotlin-coverage-on-generated-code/"/>
    <updated>2018-08-12T21:26:43-07:00</updated>
    <id>http://jivimberg.github.io/blog/2018/08/12/jacoco-and-kotlin-coverage-on-generated-code</id>
    <content type="html"><![CDATA[<p>JaCoCo works <em>flawlessly</em> with Kotlin. Except when it reports lines not covered on generated code üò°. Fortunately there‚Äôs a fix already in place.</p>

<!--more-->


<hr />

<h3><em>Update 08/26:</em> <strong>JaCoCo 0.8.2 has now officially been released</strong> üëè No need to use the <em>0.8.2-SNAPSHOT</em> anymore.</h3>

<hr />

<p><img class="center" src="/images/posts/2018-08-12/JaCoCo-before.png" width="720" title="‚ÄôJaCoCo before‚Äô" ></p>

<p><blockquote><p>What!? I didn‚Äôt even write those functions! There‚Äôs no way I‚Äôm writing tests for them. I‚Äôm pretty sure the compiler knows what it‚Äôs doing‚Ä¶</p><footer><strong>Me</strong> <cite>Every Time I Saw the Coverage Report</cite></footer></blockquote></p>

<p>Good news is that this <a href="https://github.com/goodwinnk">has been fixed</a> in the latest JaCoCo release (thanks to <a href="https://github.com/goodwinnk">goodwink</a>). Bad news is that <strong>0.8.2 is not out yet</strong> üòû</p>

<p>If you are like me, and can‚Äôt wait to get this working, you can <strong>use the SNAPSHOT version of JaCoCo</strong> making this changes on your <code>build.gradle</code>:</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="n">repositories</span> <span class="p">{</span>
</span><span class='line'>    <span class="err">‚Ä¶</span>
</span><span class='line'>    <span class="n">maven</span><span class="p">(&amp;</span><span class="n">ldquo</span><span class="p">;&lt;</span><span class="n">a</span> <span class="n">href</span><span class="p">=</span><span class="s">&quot;https://oss.sonatype.org/content/repositories/snapshots&quot;</span><span class="p">&gt;</span><span class="n">https</span><span class="p">:</span><span class="c1">//oss.sonatype.org/content/repositories/snapshots&lt;/a&gt;&amp;rdquo;)</span>
</span><span class='line'><span class="p">}&lt;/</span><span class="n">p</span><span class="p">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="p">&lt;</span><span class="n">p</span><span class="p">&gt;</span><span class="n">jacoco</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">toolVersion</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="m">0.8</span><span class="p">.</span><span class="m">2</span><span class="p">-</span><span class="n">SNAPSHOT</span><span class="p">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'><span class="p">}&lt;/</span><span class="n">p</span><span class="p">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="p">&lt;</span><span class="n">p</span><span class="p">&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p><em>(I‚Äôm using <a href="https://github.com/gradle/kotlin-dsl">Gradle with Kotlin DSL</a> in this example)</em></p>

<p>Now you can finally take your Kotlin coverage to 100% without having to write tests for <code>component1()</code> and <code>component2()</code>.</p>

<p><img class="center" src="/images/posts/2018-08-12/JaCoCo-after.png" width="720" title="‚ÄôJaCoCo after‚Äô" ></p>
]]></content>
  </entry>
  
</feed>
