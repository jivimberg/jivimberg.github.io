<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Spring | Coding Forest]]></title>
  <link href="http://jivimberg.github.io/blog/categories/spring/atom.xml" rel="self"/>
  <link href="http://jivimberg.github.io/"/>
  <updated>2018-10-08T16:56:43-07:00</updated>
  <id>http://jivimberg.github.io/</id>
  <author>
    <name><![CDATA[Juan Ignacio Vimberg]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Random Thoughts on Using Gradle With Kotlin DSL]]></title>
    <link href="http://jivimberg.github.io/blog/2018/08/28/random-thoughts-on-gradle-and-kotlin-dsl/"/>
    <updated>2018-08-28T08:36:57-07:00</updated>
    <id>http://jivimberg.github.io/blog/2018/08/28/random-thoughts-on-gradle-and-kotlin-dsl</id>
    <content type="html"><![CDATA[<p>Since Gradle 3.0 you can <a href="https://blog.gradle.org/kotlin-meets-gradle"><strong>write your build scripts using Kotlin instead of Groovy</strong></a>. I was curious, so I decided to give it a try. Here are my thoughts on the process.</p>

<!--more-->


<h1>Why?</h1>

<p>Ok, we can write our build scripts in Kotlin, but you might be wondering: <em>‚Äùwhy would I want to do that?‚Äù</em> Here are my reasons:</p>

<h2>1. All things Kotlin</h2>

<p>Our backend codebase is <em>mostly written in Kotlin</em>. We even wrote our <a href="https://jivimberg.io/blog/2018/07/03/writing-githooks-in-kotlin/">githooks using Kotlin scripts!</a> So it was only natural to use Kotlin on our build tools too.</p>

<p>Being able to use the same language across the stack means that your learning efforts pays double. This way <strong>the team doesn‚Äôt have to learn a new language just to write a simple Gradle task.</strong> And as an added bonus you can apply <em>the same testing, coverage and code inspection tools</em> that you use in production to your tooling code.</p>

<h2>2. IDE support</h2>

<p>The second reason for making the transition was IDE support. Groovy is a dynamically typed language, which makes it harder for the IDE to provide accurate code completion and script validity through type checks. Kotlin being statically typed doesn‚Äôt suffer from the same problems</p>

<p><img class="center" src="/images/posts/2018-09-11/kotlin-code-completion.png" title="‚ÄòKotlin code completion‚Äô" ></p>

<h2>3. Interoperability</h2>

<p>As you probably know <a href="https://kotlinlang.org/docs/reference/java-interop.html">Kotlin was designed with Java interoperability in mind</a>. And the same interoperability <a href="">extends to Groovy code</a>.</p>

<p>This interoperability let us <strong><a href="https://guides.gradle.org/migrating-build-logic-from-groovy-to-kotlin/#calling_kotlin_from_groovy_2">call Groovy code from Kotlin</a> and <a href="https://guides.gradle.org/migrating-build-logic-from-groovy-to-kotlin/#calling_kotlin_from_groovy">viceversa</a></strong>. Which effectively means that you can have <strong>a mix of both Groovy and Kotlin scripts working together in the same project</strong>. So no need to migrate all your build scripts at once, or to push stubborn <em>‚ÄúWally‚Äù</em> to learn Kotlin DSL.</p>

<p><img class="center" src="/images/posts/2018-09-11/wally2.png" title="‚ÄòWally‚Äô" ></p>

<h1>The exodus</h1>

<p><em>‚ÄùSo how painful was the migration?‚Äù</em> It wasn‚Äôt that bad really. Kotlin DSL was designed to be pretty similar to the classic <code>build.gradle</code> files.</p>

<p>You‚Äôll just have to <strong>push through that first moment</strong> when nothing seems to be working, your project doesn‚Äôt compile at all, and you know you‚Äôre a <code>‚åò + Z</code> away from a pristine working copy. <em>But you can&rsquo;t make an omelet without breaking a few eggs, can you?</em></p>

<p><img class="center" src="/images/posts/2018-09-11/panic.png" title="‚ÄòPanic!‚Äô" ></p>

<p><strong>I just wish there was some kind of automatic migration action in IntelliJ.</strong> Even if it‚Äôs a best effort that leaves you half way there, I‚Äôd greatly appreciate it. Ideally it should work just like when you paste some Java code into a Kotlin file: <code>‚åò + V</code> + ‚ú®<em>fairy dust</em>‚ú® and you have your <code>build.gradle.kts</code> ready to go.</p>

<h3>Resources</h3>

<p>This are the resources that help me complete the migration. Hopefully you‚Äôll find them helpful too.</p>

<ul>
<li><a href="https://guides.gradle.org/migrating-build-logic-from-groovy-to-kotlin/"><strong>Official Gradle migration guide</strong></a> <strong>Start here!</strong> You don‚Äôt have to cover the whole thing but you can skim through it and later go back to the section you need.</li>
<li><a href="https://github.com/gradle/kotlin-dsl/tree/master/samples/"><strong>Samples in the Kotlin DSL repo</strong></a> This is <strong>the go-to place for Kotlin DSL samples</strong>. You‚Äôll find yourself coming back to this repo over and over. Be sure to search the <em>Issues</em> section too.</li>
<li>For the times when the <a href="https://github.com/gradle/kotlin-dsl/tree/master/samples/">Kotlin DSL repo</a> doesn‚Äôt have what you‚Äôre looking for, I find it useful to use <a href="https://github.com/search/advanced"><strong>Github Search</strong></a> looking for code in files with <code>*.kts</code> extension.</li>
<li><a href="https://github.com/jnizet/gradle-kotlin-dsl-migration-guide"><strong>jnizet/gradle-kotlin-dsl-migration-guide</strong></a> this is another migration guide that has proven useful in the past.</li>
<li>Finally I followed <a href="https://handstandsam.com/2018/02/11/kotlin-buildsrc-for-better-gradle-dependency-management/"><strong>this article</strong></a> by <a href="https://handstandsam.com/about-me/">Handstand Sam</a> to do <em>dependency management</em> on out multi-module project.</li>
</ul>


<h1>The not so good</h1>

<h2>1. <em>‚ÄúI can‚Äôt just copy-past things from Stack Overflow‚Äù</em></h2>

<p><img class="center" src="/images/posts/2018-09-11/copy-paste.jpg" width="250" title="‚ÄòCopy paste from Stack Overflow‚Äô" ></p>

<p>This is <strong>by far the biggest drawback</strong>. In my experience most teams have one or two <em>‚Äùbuild tool experts‚Äù</em>. The rest of the team just use a few tasks and maybe add a dependency every now and then. This casual user might have a harder time using Kotlin DSL because <strong>copy-pasting pieces of code from the web will not work out of the box</strong>. Converting this snippets to Kotlin DSL is not rocket-science, but in some cases it might require some basic level of understanding of how Kotlin DSL works.</p>

<p>This is specially true when using plugins that were not designed with Kotlin DSL in mind (I‚Äôm looking at you <a href="https://github.com/google/protobuf-gradle-plugin/issues/219">protobuf Gradle plugin</a>).</p>

<h2>2. IDE support could be better</h2>

<p>Remember all the nice things I said about IDE auto-completion on the build scripts? Well let me clarify: <em>‚ÄúIDE support is awesome‚Ä¶ most of the time‚Äù</em>.</p>

<p>Once you have your script fully migrated and IntelliJ has finished indexing then everything should work just fine. But to get there you‚Äôll have to have your full <code>build.gradle</code> script fully migrated. That‚Äôs why my advice is to <strong>comment everything out and start migrating piece by piece</strong>. For example you can start with configuring the <em>repositories</em>, and <em>plugins</em> and only then move to <em>dependencies</em>.</p>

<p>This gets intensified if you are working on a <a href="https://guides.gradle.org/creating-multi-project-builds/">multi-module project</a> and/or you‚Äôre using <a href="https://docs.gradle.org/current/userguide/custom_plugins.html"><code>buildSrc</code> for custom plugins</a>.</p>

<p>The silver lining is that IDE support is getting better with each release, and once you‚Äôve migrated everything it mostly works.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Oracle, JPA and the Mystery of the String That Was Null]]></title>
    <link href="http://jivimberg.github.io/blog/2018/06/23/oracle-jpa-and-the-mistery-of-the-string-that-was-null/"/>
    <updated>2018-06-23T10:34:26-07:00</updated>
    <id>http://jivimberg.github.io/blog/2018/06/23/oracle-jpa-and-the-mistery-of-the-string-that-was-null</id>
    <content type="html"><![CDATA[<p>This is the story of how Oracle DB was messing up Kotlin‚Äôs type system, and what I did to fix it.</p>

<!--more-->


<h2>The setup</h2>

<p>Let‚Äôs start by <em>setting the stage</em>, for this particular project I was working with the following stack:</p>

<p><img class="center" src="/images/posts/2018-06-23/Stack.png" width="720" title="‚ÄôSpring + Data + Kotlin + Oracle‚Äô" ></p>

<h2>The problem</h2>

<p>So I had modeled the following <strong>Entity</strong> leveraging Kotlin‚Äôs <a href="https://kotlinlang.org/docs/reference/data-classes.html">data classes</a><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>:</p>

<xmp class="kotlin-code" data-highlight-only>
import javax.persistence.Entity
import javax.persistence.Id

//sampleStart
@Entity
data class Person(
    val name: String,
    @Id val id: Long? = null
)
//sampleEnd
</xmp>


<p>Tests where passing with flying colors, but for some reason we were noticing that <strong>the <em>name</em> would sometimes come back as <code>null</code></strong> even thought it was typed as <code>String</code> and not <code>String?</code>.</p>

<h2>The analysis</h2>

<p>To make things more difficult there where other failures in the communication layer masking the real issue. But we finally figured out what was happening when we notice <strong>it was only reproducible under the following conditions</strong>:</p>

<ul>
<li>The property <code>name</code> was empty</li>
<li>Not reproducible on tests</li>
<li>Persisting to <em>OracleDB</em> (instead of embedded H2)</li>
</ul>


<p>That‚Äôs when I discovered:
<blockquote><p>This is because Oracle internally changes empty string to NULL values. Oracle simply won&rsquo;t let insert an empty string.</p><footer><strong>Some guy on Stack Overflow <a href="https://stackoverflow.com/a/13278879/1499171">https://stackoverflow.com/a/13278879/1499171</a></strong></footer></blockquote></p>

<p>So when the data was mapped back to my <code>Person</code> object I ended up with a <code>null</code> value for <em>name</em>. This is probably only possible because <strong>Hibernate is using reflection to set the field value</strong> in runtime, thus breaking Kotlin‚Äôs <a href="https://kotlinlang.org/docs/reference/null-safety.html">null safety</a>.</p>

<h2>What I did about it</h2>

<p>The funny thing about this one is that <strong>there is not much you can do about it</strong>. <em>There is no magic configuration to tell Oracle how you want to handle empty strings.</em> Yes there are some hacks like changing <code>""</code> to <code>" "</code> but I‚Äôd rather invent a random <em>name</em> for the guy than persisting a whitespace.</p>

<p>The silver lining is that most of the time <strong>if you‚Äôre not allowing null values you probably don‚Äôt want an empty string either</strong>. Now YMMV but I know this was true for a person‚Äôs name.</p>

<p>In fact you might even want to <strong>implement a more strict validation</strong> so people can‚Äôt be named: ‚Äúüí©‚Äù.</p>

<h3>Testing</h3>

<p>First thing I did was to try to reproduce this using a test. But since I was using <code>@DataJpaTest</code> with H2 embedded DB empty strings where empty strings an nulls where nulls. So the issue was <strong>not reproducible</strong>.</p>

<p>That‚Äôs when I learned that you <strong>can tell H2 to behave like an Oracle DB</strong> using <a href="http://www.h2database.com/html/features.html">Oracle Compatibility mode</a>. To achieve this I added the following configuration to my <code>application.yml</code> under <code>test/resources</code>:</p>

<pre><code>spring:
  datasource:
    url: jdbc:h2:mem:testdb;Mode=Oracle
</code></pre>

<p>And annotated my test class with:</p>

<pre><code class="java">@RunWith(SpringRunner::class)
@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
class FormRepositoryTest {‚Ä¶}
</code></pre>

<p>And <em>voil√†</em>, now you have an <strong>H2 in memory DB dressed up as Oracle</strong>.</p>

<h3>Changing the schema</h3>

<p>The other thing I realized is that <strong>the schema allowed for <code>null</code> values</strong> on the <em>name</em> column. I‚Äôd been using <code>javax.persistence.schema-generation</code> as a starting point for my schema and <strong>I wrongly assumed</strong> it would take the hint from the Kotlin type system to prevent null values<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>.</p>

<p>Instead I had to explicitly annotate my Entity:</p>

<xmp class="kotlin-code" data-highlight-only>
import javax.persistence.Entity
import javax.persistence.Id

//sampleStart
@Entity
data class Person(
    @Column(nullable = false) val name: String,
    @Id val id: Long? = null
)
//sampleEnd
</xmp>


<p>and manually change my existing schema</p>

<pre><code>CREATE TABLE Person (
  id NUMBER(19, 0) NOT NULL,
  name VARCHAR2(255 CHAR) NOT NULL,
  PRIMARY KEY (id)
);
</code></pre>

<p>The result is that now if somebody tries to persist a Person with an empty name a <strong>big fat Exception is thrown</strong>. Or at least until I implement proper name validation.</p>

<script src="https://unpkg.com/kotlin-playground@1" data-selector=".kotlin-code"></script>



<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>If I had a dollar for every time I modeled a Person‚Ä¶<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>It would be nice right?<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spring Functional Routing]]></title>
    <link href="http://jivimberg.github.io/blog/2018/05/20/spring-functional-router/"/>
    <updated>2018-05-20T00:16:22-07:00</updated>
    <id>http://jivimberg.github.io/blog/2018/05/20/spring-functional-router</id>
    <content type="html"><![CDATA[<p>This post is about the clever tricks you can pull with Spring new <strong>functional routing</strong> and it‚Äôs Kotlin DSL.</p>

<!--more-->


<p><img class="center" src="/images/posts/2018-05-19/trainSwitch.jpg" title="‚ÄôTrain switch‚Äô" ></p>

<p>Spring 5 introduced the <a href="https://spring.io/blog/2016/09/22/new-in-spring-5-functional-web-framework">Functional Web Framework</a> and with it the ability to do functional routing. Basically instead of annotating your methods with the good old <code>@RequestMapping</code> you can now write functions that go from a <code>Request</code> to a <code>Response&lt;T&gt;</code> (called <code>HandlerFunction&lt;T&gt;</code>). And then use a <code>RouterFunction&lt;T&gt;</code> to map which path will end up in which handler.</p>

<p>Now, for the sake of brevity, I won‚Äôt talk about all the benefits of this new functional paradigm. Instead I‚Äôd like to focus on <strong>some things that can be done with functional routing that were not possible before</strong>.</p>

<p>I have to admit that <strong>at first</strong> I wasn‚Äôt sold on the functional routing thing. Why would I want to replace <code>@RequestMapping</code> with 2 different functions? Isn‚Äôt that more code to achieve the same goal? For comparison this is how a <em>simple</em> RoutingFunction could look like<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>:</p>

<xmp class="kotlin-code" data-highlight-only>
    fun router() = router {
        accept(TEXT_HTML).nest {
            GET("/") { permanentRedirect(URI("index.html")).build() }
        }
        "/api".nest {
            accept(APPLICATION_JSON).nest {
                GET("/users", userHandler::findAll)
                POST("/users", userHandler::create)
            }
        }
        resources("/**", ClassPathResource("static/"))
    } 
</xmp>


<p>It‚Äôs readable but certainly not as succinct as <code>@GetMapping("/api/users")</code>. But <strong>this terseness comes at the price of expressiveness</strong>. Or as <a href="https://spring.io/blog/2016/09/22/new-in-spring-5-functional-web-framework">this article on Spring.io</a> puts it:</p>

<blockquote><p>The <code>RouterFunction</code> has a similar purpose as a <code>@RequestMapping</code> annotation. However, there is an important distinction: with the annotation <strong>your route is limited to what can be expressed through the annotation values</strong>.</p></blockquote>

<h2>Complex routing</h2>

<p>I‚Äôll use an example to illustrate some of the things that can be achieved with complex routing. Say I have some data modeling a <em>r√©sum√©</em> that contains multiple <em>sections</em>. <strong>I want to expose each of this sections as a different REST endpoint</strong>. Underneath we need to handle each call the same way, the only difference is that we‚Äôd be processing a different <em>section</em> of data. We could do the routing like this:</p>

<xmp class="kotlin-code" data-highlight-only>
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.core.io.ClassPathResource
import org.springframework.http.MediaType
import org.springframework.web.reactive.function.server.RouterFunctions.resources
import org.springframework.web.reactive.function.server.router

//sampleStart
    enum class Section(val fieldName: String) {
    PERSONAL_INFO("personalInfo"),
    EXPERIENCE("experience"),
    SIDE_PROJECTS("sideProject"),
    EDUCATION("education"),
}

@Configuration
class Routing {
    @Bean
    fun resumeRouter(handler: ResumeHandler) = router {
        accept(MediaType.APPLICATION_JSON).nest {
            Section.values().forEach {
                GET("/${it.fieldName}", handler.getSectionHandler(it))
            }
        }
    }
}
//sampleEnd

@Component
class ResumeHandler {
fun getSectionHandler(section: Section): (ServerRequest) -\> Mono<ServerResponse> =
            { // get section from data and return response }
}
</xmp>


<p>We can iterate through the enum and create a new mapping for each of the sections with the <code>GET</code> function. Furthermore the function <code>getSectionHandler</code> can receive the enum as parameter and use it for handling the response instead of having to rely only on the <code>ServerRequest</code> context.</p>

<p>Now this is only one of the <em>tricks</em> that can be done with functional routing. Having a <a href="https://spring.io/blog/2017/08/01/spring-framework-5-kotlin-apis-the-functional-way#functional-routing-with-the-kotlin-dsl-for-spring-webflux">Kotlin DSL</a> means we can do <strong>any kind of scripting we can think of</strong> when defining the routes. As always:</p>

<p><img class="center" src="/images/posts/2018-05-19/withGreatPower.png" title="‚ÄôWith great power comes great responsibility‚Äô" ></p>

<p>Abusing this feature would make your routing logic a <strong>tangled mess</strong>, too hard to understand and maintain. So be smart about it.</p>

<script src="https://unpkg.com/kotlin-playground@1" data-selector=".kotlin-code"></script>



<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Source: [kotlin-swagger-spring-functional-template][2]<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
